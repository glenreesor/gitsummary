#!/usr/bin/python3

##  This program is free software: you can redistribute it and/or modify
##  it under the terms of the GNU General Public License, version 3,
##  as published by the Free Software Foundation.
##
##  This program is distributed in the hope that it will be useful,
##  but WITHOUT ANY WARRANTY; without even the implied warranty of
##  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
##  GNU General Public License for more details.
##
##  You should have received a copy of the GNU General Public License
##  along with this program.  If not, see <http://www.gnu.org/licenses/>.

import os
import subprocess
import sys

ANSI_NORMAL   = '0'
ANSI_BOLD     = '1'
ANSI_FLASHING = '5'

ANSI_GREEN    = '32'
ANSI_MAGENTA  = '35'
ANSI_RED      = '31'
ANSI_WHITE    = '37'
ANSI_YELLOW   = '33'

COLOR_CURRENT_BRANCH       = '\033[' + ANSI_MAGENTA + 'm'
COLOR_DETACHED_HEAD_STATE  = '\033[' + ANSI_BOLD + 'm'
COLOR_ERROR                = '\033[' + ANSI_RED + 'm'
COLOR_FILE_MODIFIED        = '\033[' + ANSI_RED + 'm'
COLOR_FILE_STAGED          = '\033[' + ANSI_GREEN + 'm'
COLOR_FILE_UNTRACKED       = '\033[' + ANSI_YELLOW  + 'm'
COLOR_IMPORTANT_BRANCH     = '\033[' + ANSI_BOLD + ';' + ANSI_FLASHING + ';' + ANSI_MAGENTA + 'm'
COLOR_NORMAL               = '\033[' + ANSI_NORMAL + 'm'
COLOR_STASH_NAME           = '\033[' + ANSI_GREEN + 'm'
COLOR_UNMERGED_BRANCH_NAME = '\033[' + ANSI_BOLD + 'm'

##----------------------------------------------------------------------------
## Global vars
##----------------------------------------------------------------------------
currentBranch = ''

devBranchPresent = False
detachedHeadState = False
masterBranchPresent = False

optionBranch = ''
optionCurrentBranch = False
optionLocalCompareTo = ''
optionLog = False

localBranches = []
originBranches = []

class Branch:
    """
    A class used to represent one branch
    """

    def __init__(self, name, remoteTrackingBranchName, isCurrent, mergeTarget):
        """
        Initialize branch info
        Args
            name:                     str:  The name of the branch
            remoteTrackingBranchName: str:  The name of the corresponding
                                            remote tracking branch, possibly None
            isCurrent:                bool: Whether this is the current branch
            mergeTarget:              str:  The name of the branch this one branch
                                            will merge to
        """

        self.name = name
        self.remoteTrackingBranchName = remoteTrackingBranchName
        self.isCurrent = isCurrent
        self.mergeTarget = mergeTarget

    def getMergeTarget(self):
        """
        Get the name of the branch that this will eventually be merged to
        :returns: str
        """

        return self.mergeTarget

    def getName(self):
        """
        Return this branch's name
        :returns: str
        """

        return self.name

    def getRemoteTrackingBranchName(self):
        """
        Return this branch's remote tracking branch name, possibly None
        :returns: str
        """

        return self.remoteTrackingBranchName

    def isCurrent(self):
        """
        Return this is the current branch
        :returns: bool
        """
        return isCurrent

class Repository:
    """
    A class used to represent the git repository contained in the current
    working directory
    """

    def __init__(self):
        """ Initialize git info corresponding to current directory """

        self.MERGE_TARGETS = {
            'default': 'dev',
            'noTarget': ['master'],
            'targets': {
                'dev': 'master'
            }
        }

        self.branches = []
        self.branchNames = []
        self.currentBranch= None
        self.detachedHeadState = False

        self._populateBranchInfo()

    def getBranch(self, branchName):
        """
        Return the Branch object whose name is branchName
        :returns: Branch The Branch object
        """

        for branch in self.branches:
            if branch.getName() == branchName:
                return branch

        return None

    def getBranches(self):
        """
        Return a List of the (local) branches
        :returns: list of Branch objects
        """

        return self.branches

    def getBranchHierarchy(self):
        """
        Return a list of Branch objects in the following order:
            - Branches with no merge target
            - Branches whose merge targets have been specified
            - Other branches
        :returns: list of Branch objects
        """

        branchList = self.MERGE_TARGETS['noTarget']
        branchList += self.MERGE_TARGETS['targets'].keys()

        for branch in self.branchNames:
            if branch not in branchList:
                branchList.append(branch)

        returnVal = []
        for branchName in branchList:
            branch = self.getBranch(branchName)
            if branch != None:
                returnVal.append(branch)

        return returnVal

    def getBranchNames(self):
        """
        Return a List of the (local) branch names
        :returns: list of str objects
        """

        return self.branchNames

    def getCurrentBranch(self):
        """
        Return the current branch
        :returns: Branch
        """

        return self.currentBranch

    def getMergeTarget(self, branchName):
        """
        Return the name of the branch that branchName will merge to
        :returns: str
        """

        if (branchName in self.MERGE_TARGETS['noTarget']):
            returnVal = None
        elif (branchName in self.MERGE_TARGETS['targets']):
            returnVal = self.MERGE_TARGETS['targets'][branchName]
        else:
            returnVal = self.MERGE_TARGETS['default']

        return returnVal

    def isDetachedHeadState(self):
        """
        Return whether the git repository is in "detached head state"
        :returns: bool
        """

        return self.detachedHeadState

    def _populateBranchInfo(self):
        """
        Populate the information about this repository's branches.
        This is intended to be called only by __init__()
        """

        branchesOutput = subprocess.check_output(
            ['git', 'branch', '--list', '-vv'],
            universal_newlines = True
        ).splitlines()

        for branchOutputLine in branchesOutput:
            isCurrentBranch = False
            remoteTrackingBranchName = None

            branchNameStart = 2
            branchNameEnd = branchOutputLine.index(' ', 2)
            branchName = branchOutputLine[branchNameStart : branchNameEnd]

            self.detachedHeadState = (branchName.startswith('(detached'))

            if not self.detachedHeadState:
                if branchOutputLine[0] == '*':
                    isCurrentBranch = True

                ##-------------------------------------------------------------
                ## Figure out remote tracking branch name
                ## Output line takes on one of these forms:
                ##   localbranch [remotebranch]
                ##   localbranch [remotebranch: ahead 2]
                ##-------------------------------------------------------------
                startDelimiter = branchOutputLine.find('[')
                closeBracket = branchOutputLine.find(']')
                colon = branchOutputLine.find(':')

                if (colon == -1 or colon > closeBracket):
                    endDelimiter = closeBracket
                else:
                    endDelimiter = colon

                if startDelimiter != -1:
                    remoteTrackingBranchName = branchOutputLine[
                        startDelimiter + 1 : endDelimiter
                    ]
                else:
                    remoteTrackingBranchName = None

                ## Create the new branch object
                newBranch = Branch(
                    branchName,
                    remoteTrackingBranchName,
                    isCurrentBranch,
                    self.getMergeTarget(branchName)
                )

                ## Assign some stuff that can only be done after branch object
                ## creation
                self.branches.append(newBranch)
                self.branchNames.append(newBranch.getName())
                if isCurrentBranch:
                    self.currentBranch = newBranch

##----------------------------------------------------------------------------
## main()
##      Drive the whole process
##----------------------------------------------------------------------------
def main():
    processCommandLineArgs(sys.argv)
    ensureGitTrackedFolder()

    ## Get all required information
    getAllBranchInfo()

    ## Now show everything
    showFilesSummary()
    showStashSummary()
    showRepositorySummary()

##----------------------------------------------------------------------------
## ensureGitTrackedFolder()
##      Make sure we're in a git tracked folder. Exit it we're not
##----------------------------------------------------------------------------
def ensureGitTrackedFolder():
    try:
        gitOutput = subprocess.check_output(
            ['git', 'status'],
            stderr=subprocess.STDOUT
        )
    except:
        print("This isn't a git tracked folder.")
        exit()

##----------------------------------------------------------------------------
## getAllBranchInfo()
##      Get the following information that is required later
##          - Name of current branch      (global currentBranch)
##          - List of all local branches  (global localBranches)
##          - List of all origin branches (global originBranches)
##----------------------------------------------------------------------------
def getAllBranchInfo():
    global currentBranch
    global detachedHeadState
    global localBranches

    ##------------------------------------------------------------------------
    ## localBranches and currentBranch
    ##------------------------------------------------------------------------
    repo = Repository()

    detachedHeadState = repo.isDetachedHeadState()
    localBranches.extend(repo.getBranchNames())
    currentBranchName = repo.getCurrentBranch().getName()

    ##------------------------------------------------------------------------
    ## originBranches
    ##------------------------------------------------------------------------
    gitBranchOutput = subprocess.check_output(
        ['git', 'branch', '--list', '--remote'],
        universal_newlines = True
    )

    for branchName in gitBranchOutput.splitlines():
        originBranchName = branchName[branchName.index('/')+1:]
        if not originBranchName.startswith('HEAD'):
            originBranches.append(originBranchName)

##----------------------------------------------------------------------------
## getCommitList()
##      Return a list of commit titles that are:
##          - In branch inBranch
##          - Not in branch notInBranch
##
##      Each commit will have the specified prefix (typically '- ' or '+ ')
##----------------------------------------------------------------------------
def getCommitList(prefix, inBranch, notInBranch):
    commitList = []

    unformattedList = subprocess.check_output(
        [
            'git',
            'rev-list',
            '--pretty=oneline',
            inBranch,
            '^' + notInBranch
        ],
        universal_newlines = True
    ).splitlines()

    ## Remove hash strings
    for commit in unformattedList:
        commitTitle = commit[commit.index(' ') + 1:]
        commitList.append(prefix + commitTitle)

    return commitList

##----------------------------------------------------------------------------
##  getLocalCompareTo()
##      Return the local branch that should be compared to when --long has
##      been specified.
##
##      If user hasn't specified the branch using --compareto, then:
##          return one of 'dev', 'master', '' which will be used for comparing
##          the specified branch to.
##
##          The value returned is determined by the existence of those branches
##          (in that order), as opposed to which branch the specified branch was
##          branched off of.
##----------------------------------------------------------------------------
def getLocalCompareTo(branchName):
    if optionLocalCompareTo != '':
        localCompareTo = optionLocalCompareTo

    elif branchName != 'dev' and branchName != 'master':
        if devBranchPresent:
            localCompareTo = 'dev'
        elif masterBranchPresent:
            localCompareTo = 'master'
        else:
            localCompareTo = ''

    elif branchName == 'dev':
        if masterBranchPresent:
            localCompareTo = 'master'
        else:
            localCompareTo = ''

    else:  ## master branch
        localCompareTo = ''

    return localCompareTo

##----------------------------------------------------------------------------
## padOrTruncate(text, length)
##      - Pad or truncate the specified string to return one of the exact
##        specified length
##----------------------------------------------------------------------------
def padOrTruncate(text, length):
    returnVal = text

    if (len(text) < length):
        formatString = '{{:<{}}}'.format(str(length))
        returnVal = formatString.format(text)

    elif (len(text) > length):
        returnVal = text[0:length]

    return returnVal

##----------------------------------------------------------------------------
## processCommandLineArgs
##      Set options variables based on command line arguments
##----------------------------------------------------------------------------
def processCommandLineArgs(args):
    global optionBranch
    global optionCurrentBranch
    global optionLocalCompareTo
    global optionLong

    optionBranch         = ''
    optionCurrentBranch  = False
    optionLocalCompareTo = ''
    optionLong           = False

    i = 1
    while i < len(args):
        if args[i] == '--branch':
            optionLong = True
            optionBranch = args[i+1]
            i += 1

        elif args[i] == '--compareto':
            optionLocalCompareTo = args[i+1]
            i += 1

        elif args[i] == '--current':
            optionCurrentBranch = True
            optionLong = True

        elif args[i] == '--long':
            optionLong = True

        elif args[i] == '--short':
            optionLong = False

        elif args[i] == '--version':
            print(args[0] + ' - Version 1.0')
            sys.exit()

        elif args[i] == '--help':
            print('Usage: ' + args[0])
            print('    --branch NAME    - Show only the specified branch. Implies --long')
            print('    --compareto NAME - Compare to the specified local branch rather')
            print('                       than dev/master')
            print('    --current        - Show only the current branch. Implies --long')
            print('    --long           - Also show commits that differ between branch')
            print('                       and dev (or master if dev does\'t exist)')
            print('    --short          - Do not show commits that differ between branch and')
            print('                       dev (or master if dev does\'t exist)')
            print('                       This is the default when --current is not specified')
            sys.exit()

        else:
            print('Unknown commandline argument:')
            print('    ' + args[i])
            sys.exit()

        i += 1

##----------------------------------------------------------------------------
## showBranchSummaryShort
##      Show a short summary of the specified branch. This consists of:
##          One line with:
##              - '*' if the branch is the current one checked out
##              - The branch name--bold if it is ahead of local dev/master
##              - 'Ahead', and/or 'Behind' if it's ahead and/or behind of
##                dev/master
##              - 'dev' or 'master', depending on which branch we're comparing to
##
##          A list of commits that are ahead/behind of this branch's origin
##----------------------------------------------------------------------------
def showBranchSummaryShort(branch):
    global currentBranch
    global devBranchPresent
    global localBranches
    global masterBranchPresent

    BRANCH_NAME_LENGTH = 54
    INDENT = '        '
    COMMIT_LENGTH = 79 - len(INDENT)

    branchName = branch.getName()
    mergeTarget = branch.getMergeTarget()

    ##--------------------------------------------------------------------
    ## Figure out if we have a corresponding branch in origin
    ##--------------------------------------------------------------------
    hasCorrespondingOrigin = False
    if originBranches.count(branchName) != 0:
        hasCorrespondingOrigin = True

    ##--------------------------------------------------------------------
    ## Get commits ahead/behind of origin
    ##--------------------------------------------------------------------
    commitsBehindOrigin = []
    commitsAheadOfOrigin = []

    if hasCorrespondingOrigin:
        commitsBehindOrigin = getCommitList('- ', 'origin/' + branchName, branchName)
        commitsAheadOfOrigin = getCommitList('+ ', branchName, 'origin/' + branchName)

    ##--------------------------------------------------------------------
    ## Get commits ahead/behind of merge target
    ##--------------------------------------------------------------------
    commitsBehindMergeTarget = []
    commitsAheadOfMergeTarget = []

    if mergeTarget != None:
        commitsBehindMergeTarget = getCommitList('- ', mergeTarget, branchName)
        commitsAheadOfMergeTarget = getCommitList('+ ', branchName, mergeTarget)

    ##--------------------------------------------------------------------
    ## Combine our lists by column
    ##--------------------------------------------------------------------
    commitsRelativeToOrigin = commitsBehindOrigin + commitsAheadOfOrigin
    commitsRelativeToMergeTarget = commitsBehindMergeTarget + commitsAheadOfMergeTarget

    ##--------------------------------------------------------------------
    ## Formatted Branch Name
    ##--------------------------------------------------------------------
    currentBranchIndicator = ' '
    if branchName == currentBranch:
        if branchName != 'dev' and branchName != 'master':
            currentBranchIndicator = COLOR_CURRENT_BRANCH + '*' + COLOR_NORMAL
        else:
            currentBranchIndicator = COLOR_IMPORTANT_BRANCH + '*' + COLOR_NORMAL

    ##--------------------------------------------------------------------
    ## Ahead / behind of merge target
    ##--------------------------------------------------------------------
    ahead = '-----'
    if len(commitsAheadOfMergeTarget) != 0:
        ahead = 'Ahead'

    behind = '------'
    if len(commitsBehindMergeTarget) != 0:
        behind = 'Behind'

    ##--------------------------------------------------------------------
    ## Print branchname line
    ##--------------------------------------------------------------------
    if len(commitsRelativeToOrigin) > 0:
        print()

    outputString = currentBranchIndicator + ' '

    if len(commitsAheadOfMergeTarget) != 0:
        outputString += COLOR_UNMERGED_BRANCH_NAME
        outputString += padOrTruncate(branchName, BRANCH_NAME_LENGTH) + ' '
        outputString += COLOR_NORMAL

    else:
        outputString += padOrTruncate(branchName, BRANCH_NAME_LENGTH) + ' '

    outputString += padOrTruncate(ahead, 7) + ' '
    outputString += padOrTruncate(behind, 7) + ' '

    if mergeTarget != None:
        outputString += mergeTarget

    print(outputString)

    ##--------------------------------------------------------------------
    ## Print commits relative to origin
    ##--------------------------------------------------------------------
    for commit in commitsRelativeToOrigin:
        outputString = INDENT + padOrTruncate(commit, COMMIT_LENGTH)

        print(outputString)

    if len(commitsRelativeToOrigin) != 0:
        print()

##----------------------------------------------------------------------------
## showBranchSummaryFull
##      Show a full summary of the specified branch. This consists of:
##          One line with:
##              - '*' if the branch is the current one checked out
##              - The branch name--bold if it is ahead of local dev/master
##              - 'Ahead', and/or 'Behind' if it's ahead and/or behind of
##                dev/master
##              - 'dev' or 'master', depending on which branch we're comparing to
##
##          One column listing commits ahead/behind of this branch's origin
##          One column listing commits ahead/behind of dev/master
##----------------------------------------------------------------------------
def showBranchSummaryFull(branch):
    global currentBranch
    global devBranchPresent
    global localBranches
    global masterBranchPresent

    INDENT = '        '
    COMMIT_LENGTH = 60

    branchName = branch.getName()
    mergeTarget = branch.getMergeTarget()

    ##--------------------------------------------------------------------
    ## Figure out if we have a corresponding branch in origin
    ##--------------------------------------------------------------------
    hasCorrespondingOrigin = False
    if originBranches.count(branchName) != 0:
        hasCorrespondingOrigin = True

    ##--------------------------------------------------------------------
    ## Get commits ahead/behind of origin
    ##--------------------------------------------------------------------
    commitsBehindOrigin = []
    commitsAheadOfOrigin = []

    if hasCorrespondingOrigin:
        commitsBehindOrigin = getCommitList('- ', 'origin/' + branchName, branchName)
        commitsAheadOfOrigin = getCommitList('+ ', branchName, 'origin/' + branchName)

    ##--------------------------------------------------------------------
    ## Get commits ahead/behind of merge target
    ##--------------------------------------------------------------------
    commitsBehindMergeTarget = []
    commitsAheadOfMergeTarget = []

    if mergeTarget != None:
        commitsBehindMergeTarget = getCommitList('- ', mergeTarget, branchName)
        commitsAheadOfMergeTarget = getCommitList('+ ', branchName, mergeTarget)

    ##--------------------------------------------------------------------
    ## Combine our lists by column
    ##--------------------------------------------------------------------
    commitsRelativeToOrigin = commitsBehindOrigin + commitsAheadOfOrigin
    commitsRelativeToMergeTarget = commitsBehindMergeTarget + commitsAheadOfMergeTarget

    ##--------------------------------------------------------------------
    ## Formatted Branch Name
    ##--------------------------------------------------------------------
    currentBranchIndicator = ' '
    if branchName == currentBranch:
        currentBranchIndicator = COLOR_CURRENT_BRANCH + '*' + COLOR_NORMAL

    formattedBranchName = branchName
    if len(commitsAheadOfMergeTarget) != 0:
        formattedBranchName =COLOR_UNMERGED_BRANCH_NAME + branchName + COLOR_NORMAL

    ##--------------------------------------------------------------------
    ## Print branchname line
    ##--------------------------------------------------------------------
    print(currentBranchIndicator + ' ' + formattedBranchName)

    ##--------------------------------------------------------------------
    ## Commits differing between origin and/or mergeTarget
    ##--------------------------------------------------------------------
    if len(commitsRelativeToOrigin) > 0 or len(commitsRelativeToMergeTarget) > 0:
        outputLine = INDENT
        outputLine += padOrTruncate('Relative to Origin', COMMIT_LENGTH) + '  '
        outputLine += padOrTruncate(
            'Relative to ' + mergeTarget,
            COMMIT_LENGTH
        )
        print(outputLine)

        indexOrigin = 0
        indexMergeTarget = 0

        while (indexOrigin < len(commitsRelativeToOrigin) or
               indexMergeTarget < len(commitsRelativeToMergeTarget)):

            outputLine = INDENT
            if indexOrigin < len(commitsRelativeToOrigin):
                outputLine += padOrTruncate(
                    commitsRelativeToOrigin[indexOrigin],
                    COMMIT_LENGTH
                )
                indexOrigin += 1
            else:
                outputLine += padOrTruncate('', COMMIT_LENGTH)

            if indexMergeTarget < len(commitsRelativeToMergeTarget):
                outputLine += '  '
                outputLine += padOrTruncate(
                    commitsRelativeToMergeTarget[indexMergeTarget],
                    COMMIT_LENGTH
                )
                indexMergeTarget += 1

            print(outputLine)

##----------------------------------------------------------------------------
## showFilesSummary()
##      Summarize the following for the current branch:
##          Staged changes
##          Unstaged changes
##          Untracked files
##----------------------------------------------------------------------------
def showFilesSummary():
    INDENT = '           '

    gitStatusOutput = subprocess.check_output(
        ['git', 'status', '--porcelain'],
        universal_newlines = True
    )
    gitStatusLines = gitStatusOutput.splitlines()

    ## Keep a count of files outputted to make sure we get them all
    printedFiles = 0

    ##------------------------------------------------------------------------
    ## Staged files
    ##------------------------------------------------------------------------
    print('Staged')
    for line in gitStatusLines:
        indexStatus = line[0]
        fileName = line[3:]

        if indexStatus != ' ' and indexStatus != '?':
            print(COLOR_FILE_STAGED, end='')
            print(INDENT + indexStatus + ' ' + fileName)
            print(COLOR_NORMAL, end='')

            printedFiles += 1

    ##------------------------------------------------------------------------
    ## Modified
    ##------------------------------------------------------------------------
    print()
    print('Modified')
    for line in gitStatusLines:
        workingTreeStatus = line[1]
        fileName = line[3:]

        if workingTreeStatus != ' ' and workingTreeStatus != '?':
            print(COLOR_FILE_MODIFIED, end='')
            print(INDENT + workingTreeStatus + ' ' + fileName)
            print(COLOR_NORMAL, end='')

            printedFiles += 1

    ##------------------------------------------------------------------------
    ## Untracked files
    ##------------------------------------------------------------------------
    print()
    print('Untracked')
    for line in gitStatusLines:
        indexStatus = line[0]
        fileName = line[3:]

        if indexStatus == '?':
            print(COLOR_FILE_UNTRACKED, end='')
            print(INDENT + fileName)
            print(COLOR_NORMAL, end='')

            printedFiles += 1

##----------------------------------------------------------------------------
## showRepositorySummary()
##      List all branches and show:
##          - First line:
##              - Branch/repository we'll be comparing to. Precedence is:
##                  - origin (if exists)
##                  - local dev (if exists and we're not dev)
##                  - local master (last resort, unless we're master)
##              - '*' if this is the current branch
##              - Branch Name
##                  - Make it bold face if it hasn't been merged into:
##                  - dev (if exists)
##                  - master (last resort)
##              - Flashing arrow if this is the current branch
##
##          - Following lines:
##              - Commits differing between the above branch/repository
##----------------------------------------------------------------------------
def showRepositorySummary():
    global currentBranch
    global devBranchPresent
    global detachedHeadState
    global localBranches
    global masterBranchPresent
    global optionCurrentBranch
    global optionLong

    repository = Repository()

    ##-------------------------------------------------------------------------
    ## Figure out if dev and/or master branches are present
    ##-------------------------------------------------------------------------
    devBranchPresent = False
    masterBranchPresent = False

    if localBranches.count('dev') != 0:
        devBranchPresent = True

    if localBranches.count('master') != 0:
        masterBranchPresent = True

    ##-------------------------------------------------------------------------
    ## We may be in detached head state
    ##-------------------------------------------------------------------------
    if repository.isDetachedHeadState():
        print(
            '\n' +
            COLOR_DETACHED_HEAD_STATE + 'Currently in detached head state' +
            COLOR_NORMAL
        )

    ##-------------------------------------------------------------------------
    ## Appropriate titles
    ##-------------------------------------------------------------------------
    print()

    if optionLong:
        print('Local Branches')
    else:
        print('Local Branches Commits Relative to Origin')

    print('Bold = not merged to dev (or master if no dev)')
    print()

    ##-------------------------------------------------------------------------
    ## One of:
    ##      - current branch (--current)
    ##      - manually selected branch (--branch xyz)
    ##      - all branches
    ##-------------------------------------------------------------------------
    if optionCurrentBranch:
        if optionLong:
            showBranchSummaryFull(repository.getCurrentBranch())
        else:
            showBranchSummaryShort(repository.getCurrentBranch())

    elif optionBranch != '':
        if optionLong:
            showBranchSummaryFull(repository.getBranch(optionBranch))
        else:
            showBranchSummaryShort(repository.getBranch(optionBranch))

    else:
        for branch in repository.getBranchHierarchy():
            if optionLong:
                showBranchSummaryFull(branch)
            else:
                showBranchSummaryShort(branch)

##----------------------------------------------------------------------------
## showStashSummary()
##      List all the stashes nicely
##----------------------------------------------------------------------------
def showStashSummary():
    INDENT1 = '    '
    INDENT2 = INDENT1 + '          '

    gitStashOutput = subprocess.check_output(
        ['git', 'stash', 'list'],
        universal_newlines = True
    )
    gitStashLines = gitStashOutput.splitlines()

    print()
    print('Stashes')

    i = 0

    for line in gitStashLines:
        endOfName = line.index(':')

        stashName = line[0:endOfName]
        stashDescription = line[endOfName + 1:]

        if i != 0:
            print()

        print(COLOR_STASH_NAME, end='')
        print(INDENT1 + stashName)
        print(COLOR_NORMAL, end='')
        print(padOrTruncate(INDENT2 + stashDescription, 79))

##----------------------------------------------------------------------------
##----------------------------------------------------------------------------
main()
