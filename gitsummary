#!/usr/bin/python3

##  This program is free software: you can redistribute it and/or modify
##  it under the terms of the GNU General Public License, version 3,
##  as published by the Free Software Foundation.
##
##  This program is distributed in the hope that it will be useful,
##  but WITHOUT ANY WARRANTY; without even the implied warranty of
##  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
##  GNU General Public License for more details.
##
##  You should have received a copy of the GNU General Public License
##  along with this program.  If not, see <http://www.gnu.org/licenses/>.

import os
import subprocess
import sys

ANSI_NORMAL   = '0'
ANSI_BOLD     = '1'
ANSI_FLASHING = '5'

ANSI_GREEN    = '32'
ANSI_MAGENTA  = '35'
ANSI_RED      = '31'
ANSI_WHITE    = '37'
ANSI_YELLOW   = '33'

COLOR_CURRENT_BRANCH       = '\033[' + ANSI_MAGENTA + 'm'
COLOR_DETACHED_HEAD_STATE  = '\033[' + ANSI_BOLD + 'm'
COLOR_ERROR                = '\033[' + ANSI_RED + 'm'
COLOR_FILE_MODIFIED        = '\033[' + ANSI_RED + 'm'
COLOR_FILE_STAGED          = '\033[' + ANSI_GREEN + 'm'
COLOR_FILE_UNTRACKED       = '\033[' + ANSI_YELLOW  + 'm'
COLOR_IMPORTANT_BRANCH     = '\033[' + ANSI_BOLD + ';' + ANSI_FLASHING + ';' + ANSI_MAGENTA + 'm'
COLOR_NORMAL               = '\033[' + ANSI_NORMAL + 'm'
COLOR_STASH_NAME           = '\033[' + ANSI_GREEN + 'm'
COLOR_UNMERGED_BRANCH_NAME = '\033[' + ANSI_BOLD + 'm'

##----------------------------------------------------------------------------
## Global vars
##----------------------------------------------------------------------------
optionBranch = ''
optionCurrentBranch = False
optionLocalCompareTo = ''
optionLog = False

class Branch:
    """
    A class used to represent one branch
    """

    def __init__(self, name, important, current, remoteTrackingBranchName, mergeTargetName):
        """
        Initialize this Branch
        Args
            name:                     str:  The name of the branch
            important:                bool: Whether this branch is "important"
                                            and needs to be flagged in output
            current:                  bool: Whether this is the current branch
            remoteTrackingBranchName: str:  The name of the corresponding
                                            remote tracking branch, possibly None
            mergeTargetName:          str:  The name of the branch this one branch
                                            will merge to
        """

        self.name = name
        self.important = important
        self.current = current
        self.remoteTrackingBranchName = remoteTrackingBranchName
        self.mergeTargetName = mergeTargetName

    def getCommitsNotIn(self, branchName):
        """
        Get a list of Commit objects for the commits that are in the current
        branch, but not in the specified branch
        :returns: list of Commit objects
        """

        commitHashes = subprocess.check_output(
            [
                'git',
                'rev-list',
                self.name,
                '^' + branchName
            ],
            universal_newlines = True
        ).splitlines()

        commits = []
        for hash in commitHashes:
            commits.append(Commit(hash))

        return commits

    def getCommitsOnlyIn(self, branchName):
        """
        Get a list of Commit objects for the commits that are in the specified
        branch, but not in the current branch
        :returns: list of Commit objects
        """

        commitHashes = subprocess.check_output(
            [
                'git',
                'rev-list',
                branchName,
                '^' + self.name
            ],
            universal_newlines = True
        ).splitlines()

        commits = []
        for hash in commitHashes:
            commits.append(Commit(hash))

        return commits
    def getMergeTargetName(self):
        """
        Get the name of the branch that this will eventually be merged to
        :returns: str
        """

        return self.mergeTargetName

    def getName(self):
        """
        Return this branch's name
        :returns: str
        """

        return self.name

    def getRemoteTrackingBranchName(self):
        """
        Return this branch's remote tracking branch name, possibly None
        :returns: str
        """

        return self.remoteTrackingBranchName

    def isCurrent(self):
        """
        Return this is the current branch
        :returns: bool
        """

        return self.current

    def isImportant(self):
        """
        Return this is an "important" branch
        :returns: bool
        """
        return self.important

class Commit:
    """
    A class used to represent a commit
    """

    def __init__(self, hash):
        """
        Initialize the commit
        Args
            hash: str: The hash for this particular commit
        """

        self.hash = hash
        self.description = ''
        self._setDescription()

    def getDescription(self):
        """
        Return the description for this commit
        :returns: str
        """

        return self.description

    def _setDescription(self):
        """
        Set self.description. This is intended to be called only by __init__()
        """
        gitShowOutput = subprocess.check_output(
            [
                'git',
                'show',
                self.hash,
                '--pretty=oneline'
            ],
            universal_newlines = True
        ).splitlines()

        descriptionStart = gitShowOutput[0].find(' ') + 1
        self.description = gitShowOutput[0][descriptionStart:]

class Repository:
    """
    A class used to represent the git repository contained in the current
    working directory
    """

    def __init__(self):
        """ Initialize git info corresponding to current directory """

        ## "Important" branches that should be flagged in output
        self.IMPORTANT_BRANCHES = ['dev', 'master']

        ## A mapping of branches to their corresponding merge targets
        self.MERGE_TARGETS = {
            'default': 'dev',
            'noTarget': ['master'],
            'targets': {
                'dev': 'master'
            }
        }


        self.branches = []
        self.branchNames = []
        self.currentBranch= None
        self.detachedHeadState = False
        self.filesModified = []
        self.filesStaged = []
        self.filesUntracked = []
        self.stashes = []

        self.ensureGitTrackedFolder()
        self._populateBranchInfo()
        self._populateFilesInfo()
        self._populateStashInfo()

    def ensureGitTrackedFolder(self):
        """ Ensure this is a git-tracked folder """

        try:
            gitOutput = subprocess.check_output(
                ['git', 'status'],
                stderr=subprocess.STDOUT
            )
        except:
            print("This isn't a git tracked folder.")
            exit()

    def getBranch(self, branchName):
        """
        Return the Branch object whose name is branchName
        :returns: Branch The Branch object
        """

        for branch in self.branches:
            if branch.getName() == branchName:
                return branch

        return None

    def getBranches(self):
        """
        Return a List of the (local) branches
        :returns: list of Branch objects
        """

        return self.branches

    def getBranchHierarchy(self):
        """
        Return a list of Branch objects in the following order:
            - Branches with no merge target
            - Branches whose merge targets have been specified
            - Other branches
        :returns: list of Branch objects
        """

        branchList = self.MERGE_TARGETS['noTarget']
        branchList += self.MERGE_TARGETS['targets'].keys()

        for branch in self.branchNames:
            if branch not in branchList:
                branchList.append(branch)

        returnVal = []
        for branchName in branchList:
            branch = self.getBranch(branchName)
            if branch != None:
                returnVal.append(branch)

        return returnVal

    def getCurrentBranch(self):
        """
        Return the current branch
        :returns: Branch
        """

        return self.currentBranch

    def getFilesModified(self):
        """
        Get a list of this repository's modified files
        :returns: list of str
        """

        return self.filesModified

    def getFilesStaged(self):
        """
        Get a list of this repository's staged files
        :returns: list of str
        """

        return self.filesStaged

    def getFilesUntracked(self):
        """
        Get a list of this repository's untracked files
        :returns: list of str
        """

        return self.filesUntracked

    def getMergeTargetName(self, branchName):
        """
        Return the name of the branch that branchName will merge to
        :returns: str
        """

        if (branchName in self.MERGE_TARGETS['noTarget']):
            returnVal = None
        elif (branchName in self.MERGE_TARGETS['targets']):
            returnVal = self.MERGE_TARGETS['targets'][branchName]
        else:
            returnVal = self.MERGE_TARGETS['default']

        return returnVal

    def getStashes(self):
        """
        Return a list of Stash objects
        :returns: list of STash objects
        """

        return self.stashes

    def isDetachedHeadState(self):
        """
        Return whether the git repository is in "detached head state"
        :returns: bool
        """

        return self.detachedHeadState

    def _populateBranchInfo(self):
        """
        Populate the information about this repository's branches.
        This is intended to be called only by __init__()
        """

        branchesOutput = subprocess.check_output(
            ['git', 'branch', '--list', '-vv'],
            universal_newlines = True
        ).splitlines()

        for branchOutputLine in branchesOutput:
            isCurrentBranch = False
            remoteTrackingBranchName = None

            branchNameStart = 2
            branchNameEnd = branchOutputLine.index(' ', 2)
            branchName = branchOutputLine[branchNameStart : branchNameEnd]

            self.detachedHeadState = (branchName.startswith('(detached'))

            if not self.detachedHeadState:
                if branchOutputLine[0] == '*':
                    isCurrentBranch = True

                ##-------------------------------------------------------------
                ## Figure out remote tracking branch name
                ## Output line takes on one of these forms:
                ##   localbranch [remotebranch]
                ##   localbranch [remotebranch: ahead 2]
                ##-------------------------------------------------------------
                startDelimiter = branchOutputLine.find('[')
                closeBracket = branchOutputLine.find(']')
                colon = branchOutputLine.find(':')

                if (colon == -1 or colon > closeBracket):
                    endDelimiter = closeBracket
                else:
                    endDelimiter = colon

                if startDelimiter != -1:
                    remoteTrackingBranchName = branchOutputLine[
                        startDelimiter + 1 : endDelimiter
                    ]
                else:
                    remoteTrackingBranchName = None

                ## Create the new branch object
                isImportant = False
                if branchName in self.IMPORTANT_BRANCHES:
                    isImportant = True

                newBranch = Branch(
                    branchName,
                    isImportant,
                    isCurrentBranch,
                    remoteTrackingBranchName,
                    self.getMergeTargetName(branchName)
                )

                ## Assign some stuff that can only be done after branch object
                ## creation
                self.branches.append(newBranch)
                self.branchNames.append(newBranch.getName())
                if isCurrentBranch:
                    self.currentBranch = newBranch

    def _populateFilesInfo(self):
        """
        Populate the information about this repository's files
        (staged, modified, and untracked).
        This is intended to be called only by __init__()
        """

        gitStatusOutput = subprocess.check_output(
            ['git', 'status', '--porcelain'],
            universal_newlines = True
        ).splitlines()

        for line in gitStatusOutput:
            indexStatus = line[0]
            workingTreeStatus = line[1]
            fileName = line[3:]

            newRepositoryFile = RepositoryFile(
                fileName,
                indexStatus,
                workingTreeStatus
            )

            if indexStatus != ' ' and indexStatus != '?':
                self.filesStaged.append(newRepositoryFile)

            if workingTreeStatus != ' ' and workingTreeStatus != '?':
                self.filesModified.append(newRepositoryFile)

            if indexStatus == '?':
                self.filesUntracked.append(newRepositoryFile)

    def _populateStashInfo(self):
        """
        Populate the information about this repository's stashes.
        This is intended to be called only by __init__()
        """

        stashesOutput = subprocess.check_output(
            ['git', 'stash', 'list'],
            universal_newlines = True
        ).splitlines()

        for stashLine in stashesOutput:
            nameEnd = stashLine.find(':')
            newStash = Stash(stashLine[:nameEnd], stashLine[nameEnd+2:])
            self.stashes.append(newStash)

class RepositoryFile:
    """
    A class used to represent a staged, modified, or untracked file in
    the current git repository
    """

    def __init__(self, name, indexStatus, workingTreeStatus):
        """
        Initialize this RepositoryFile
        Args
            name:             str: The name of this file
            indexStatus       str: The one-character index status of this file
            workingTreeStatus str: The one-character working tree status of this file
        """
        self.name = name
        self.indexStatus = indexStatus
        self.workingTreeStatus = workingTreeStatus

    def getIndexStatus(self):
        """
        Get the one-character index status of this file
        :returns: str
        """

        return self.indexStatus

    def getName(self):
        """
        Get the fully qualified name of this file
        :returns: str
        """

        return self.name

    def getWorkingTreeStatus(self):
        """
        Get the one-character working tree status of this file
        :returns: str
        """

        return self.workingTreeStatus

class Stash:
    """
    A class used to represent one stash
    """

    def __init__(self, name, description):
        """ Initialize a stash """

        self.name = name
        self.description = description

    def getDescription(self):
        """
        Return the description of this stash
        :returns: str
        """
        return self.description

    def getName(self):
        """
        Return the name of this stash
        :returns: str
        """

        return self.name

##----------------------------------------------------------------------------
## main()
##      Drive the whole process
##----------------------------------------------------------------------------
def main():
    processCommandLineArgs(sys.argv)

    repository = Repository()

    showFilesSummary(repository)
    showStashSummary(repository)
    showRepositorySummary(repository)

##----------------------------------------------------------------------------
## padOrTruncate(text, length)
##      - Pad or truncate the specified string to return one of the exact
##        specified length
##----------------------------------------------------------------------------
def padOrTruncate(text, length):
    returnVal = text

    if (len(text) < length):
        formatString = '{{:<{}}}'.format(str(length))
        returnVal = formatString.format(text)

    elif (len(text) > length):
        returnVal = text[0:length]

    return returnVal

##----------------------------------------------------------------------------
## processCommandLineArgs
##      Set options variables based on command line arguments
##----------------------------------------------------------------------------
def processCommandLineArgs(args):
    global optionBranch
    global optionCurrentBranch
    global optionLocalCompareTo
    global optionLong

    optionBranch         = ''
    optionCurrentBranch  = False
    optionLocalCompareTo = ''
    optionLong           = False

    i = 1
    while i < len(args):
        if args[i] == '--branch':
            optionLong = True
            optionBranch = args[i+1]
            i += 1

        elif args[i] == '--compareto':
            optionLocalCompareTo = args[i+1]
            i += 1

        elif args[i] == '--current':
            optionCurrentBranch = True
            optionLong = True

        elif args[i] == '--long':
            optionLong = True

        elif args[i] == '--short':
            optionLong = False

        elif args[i] == '--version':
            print(args[0] + ' - Version 1.0')
            sys.exit()

        elif args[i] == '--help':
            print('Usage: ' + args[0])
            print('    --branch NAME    - Show only the specified branch. Implies --long')
            print('    --compareto NAME - Compare to the specified local branch rather')
            print('                       than dev/master')
            print('    --current        - Show only the current branch. Implies --long')
            print('    --long           - Also show commits that differ between branch')
            print('                       and dev (or master if dev does\'t exist)')
            print('    --short          - Do not show commits that differ between branch and')
            print('                       dev (or master if dev does\'t exist)')
            print('                       This is the default when --current is not specified')
            sys.exit()

        else:
            print('Unknown commandline argument:')
            print('    ' + args[i])
            sys.exit()

        i += 1

##----------------------------------------------------------------------------
## showBranchSummaryShort
##      Show a short summary of the specified branch. This consists of:
##          One line with:
##              - '*' if the branch is the current one checked out
##              - The branch name--bold if it is ahead of local dev/master
##              - 'Ahead', and/or 'Behind' if it's ahead and/or behind of
##                dev/master
##              - 'dev' or 'master', depending on which branch we're comparing to
##
##          A list of commits that are ahead/behind of this branch's origin
##----------------------------------------------------------------------------
def showBranchSummaryShort(branch):
    BRANCH_NAME_LENGTH = 54
    INDENT = '        '
    COMMIT_LENGTH = 79 - len(INDENT)

    branchName = branch.getName()
    mergeTargetName = branch.getMergeTargetName()

    ##--------------------------------------------------------------------
    ## Figure out if we have a corresponding branch in origin
    ##--------------------------------------------------------------------
    remoteTrackingBranchName = branch.getRemoteTrackingBranchName()

    ##--------------------------------------------------------------------
    ## Get commits ahead/behind of origin
    ##--------------------------------------------------------------------
    commitsBehindOrigin = []
    commitsAheadOfOrigin = []

    if remoteTrackingBranchName != None:
        for commit in branch.getCommitsNotIn(remoteTrackingBranchName):
            commitsAheadOfOrigin.append('+ ' + commit.getDescription())

        for commit in branch.getCommitsOnlyIn(remoteTrackingBranchName):
            commitsBehindOrigin.append('- ' + commit.getDescription())

    ##--------------------------------------------------------------------
    ## Get commits ahead/behind of merge target
    ##--------------------------------------------------------------------
    commitsBehindMergeTarget = []
    commitsAheadOfMergeTarget = []

    if mergeTargetName != None:
        for commit in branch.getCommitsNotIn(mergeTargetName):
            commitsAheadOfMergeTarget.append('+ ' + commit.getDescription())

        for commit in branch.getCommitsOnlyIn(mergeTargetName):
            commitsBehindMergeTarget.append('- ' + commit.getDescription())

    ##--------------------------------------------------------------------
    ## Combine our lists by column
    ##--------------------------------------------------------------------
    commitsRelativeToOrigin = commitsBehindOrigin + commitsAheadOfOrigin
    commitsRelativeToMergeTarget = commitsBehindMergeTarget + commitsAheadOfMergeTarget

    ##--------------------------------------------------------------------
    ## Formatted Branch Name
    ##--------------------------------------------------------------------
    currentBranchIndicator = ' '
    if branch.isCurrent():
        if branch.isImportant():
            currentBranchIndicator = COLOR_IMPORTANT_BRANCH + '*' + COLOR_NORMAL
        else:
            currentBranchIndicator = COLOR_CURRENT_BRANCH + '*' + COLOR_NORMAL

    ##--------------------------------------------------------------------
    ## Ahead / behind of merge target
    ##--------------------------------------------------------------------
    ahead = '-----'
    if len(commitsAheadOfMergeTarget) != 0:
        ahead = 'Ahead'

    behind = '------'
    if len(commitsBehindMergeTarget) != 0:
        behind = 'Behind'

    ##--------------------------------------------------------------------
    ## Print branchname line
    ##--------------------------------------------------------------------
    if len(commitsRelativeToOrigin) > 0:
        print()

    outputString = currentBranchIndicator + ' '

    if len(commitsAheadOfMergeTarget) != 0:
        outputString += COLOR_UNMERGED_BRANCH_NAME
        outputString += padOrTruncate(branchName, BRANCH_NAME_LENGTH) + ' '
        outputString += COLOR_NORMAL

    else:
        outputString += padOrTruncate(branchName, BRANCH_NAME_LENGTH) + ' '

    outputString += padOrTruncate(ahead, 7) + ' '
    outputString += padOrTruncate(behind, 7) + ' '

    if mergeTargetName != None:
        outputString += mergeTargetName

    print(outputString)

    ##--------------------------------------------------------------------
    ## Print commits relative to origin
    ##--------------------------------------------------------------------
    for commit in commitsRelativeToOrigin:
        outputString = INDENT + padOrTruncate(commit, COMMIT_LENGTH)

        print(outputString)

    if len(commitsRelativeToOrigin) != 0:
        print()

##----------------------------------------------------------------------------
## showBranchSummaryFull
##      Show a full summary of the specified branch. This consists of:
##          One line with:
##              - '*' if the branch is the current one checked out
##              - The branch name--bold if it is ahead of local dev/master
##              - 'Ahead', and/or 'Behind' if it's ahead and/or behind of
##                dev/master
##              - 'dev' or 'master', depending on which branch we're comparing to
##
##          One column listing commits ahead/behind of this branch's origin
##          One column listing commits ahead/behind of dev/master
##----------------------------------------------------------------------------
def showBranchSummaryFull(branch):
    INDENT = '        '
    COMMIT_LENGTH = 60

    branchName = branch.getName()
    mergeTargetName = branch.getMergeTargetName()

    ##--------------------------------------------------------------------
    ## Figure out if we have a corresponding branch in origin
    ##--------------------------------------------------------------------
    remoteTrackingBranchName = branch.getRemoteTrackingBranchName()

    ##--------------------------------------------------------------------
    ## Get commits ahead/behind of origin
    ##--------------------------------------------------------------------
    commitsBehindOrigin = []
    commitsAheadOfOrigin = []

    ##--------------------------------------------------------------------
    ## Get commits ahead/behind of origin
    ##--------------------------------------------------------------------
    commitsBehindOrigin = []
    commitsAheadOfOrigin = []

    if remoteTrackingBranchName != None:
        for commit in branch.getCommitsNotIn(remoteTrackingBranchName):
            commitsAheadOfOrigin.append('+ ' + commit.getDescription())

        for commit in branch.getCommitsOnlyIn(remoteTrackingBranchName):
            commitsBehindOrigin.append('- ' + commit.getDescription())

    ##--------------------------------------------------------------------
    ## Get commits ahead/behind of merge target
    ##--------------------------------------------------------------------
    commitsBehindMergeTarget = []
    commitsAheadOfMergeTarget = []

    if mergeTargetName != None:
        for commit in branch.getCommitsNotIn(mergeTargetName):
            commitsAheadOfMergeTarget.append('+ ' + commit.getDescription())

        for commit in branch.getCommitsOnlyIn(mergeTargetName):
            commitsBehindMergeTarget.append('- ' + commit.getDescription())

    ##--------------------------------------------------------------------
    ## Combine our lists by column
    ##--------------------------------------------------------------------
    commitsRelativeToOrigin = commitsBehindOrigin + commitsAheadOfOrigin
    commitsRelativeToMergeTarget = commitsBehindMergeTarget + commitsAheadOfMergeTarget

    ##--------------------------------------------------------------------
    ## Formatted Branch Name
    ##--------------------------------------------------------------------
    currentBranchIndicator = ' '
    if branch.isCurrent():
        currentBranchIndicator = COLOR_CURRENT_BRANCH + '*' + COLOR_NORMAL

    formattedBranchName = branchName
    if len(commitsAheadOfMergeTarget) != 0:
        formattedBranchName =COLOR_UNMERGED_BRANCH_NAME + branchName + COLOR_NORMAL

    ##--------------------------------------------------------------------
    ## Print branchname line
    ##--------------------------------------------------------------------
    print(currentBranchIndicator + ' ' + formattedBranchName)

    ##--------------------------------------------------------------------
    ## Commits differing between origin and/or mergeTarget
    ##--------------------------------------------------------------------
    if len(commitsRelativeToOrigin) > 0 or len(commitsRelativeToMergeTarget) > 0:
        outputLine = INDENT
        outputLine += padOrTruncate('Relative to Origin', COMMIT_LENGTH) + '  '
        outputLine += padOrTruncate(
            'Relative to ' + mergeTargetName,
            COMMIT_LENGTH
        )
        print(outputLine)

        indexOrigin = 0
        indexMergeTarget = 0

        while (indexOrigin < len(commitsRelativeToOrigin) or
               indexMergeTarget < len(commitsRelativeToMergeTarget)):

            outputLine = INDENT
            if indexOrigin < len(commitsRelativeToOrigin):
                outputLine += padOrTruncate(
                    commitsRelativeToOrigin[indexOrigin],
                    COMMIT_LENGTH
                )
                indexOrigin += 1
            else:
                outputLine += padOrTruncate('', COMMIT_LENGTH)

            if indexMergeTarget < len(commitsRelativeToMergeTarget):
                outputLine += '  '
                outputLine += padOrTruncate(
                    commitsRelativeToMergeTarget[indexMergeTarget],
                    COMMIT_LENGTH
                )
                indexMergeTarget += 1

            print(outputLine)

##----------------------------------------------------------------------------
## showFilesSummary()
##      Summarize the following for the current branch:
##          Staged changes
##          Unstaged changes
##          Untracked files
##----------------------------------------------------------------------------
def showFilesSummary(repository):
    INDENT = '           '

    print('Staged')
    for repoFile in repository.getFilesStaged():
        print(COLOR_FILE_STAGED, end='')
        print(INDENT + repoFile.getIndexStatus() + ' ' + repoFile.getName())
        print(COLOR_NORMAL, end='')

    print()
    print('Modified')
    for repoFile in repository.getFilesModified():
        print(COLOR_FILE_MODIFIED, end='')
        print(INDENT + repoFile.getWorkingTreeStatus() + ' ' + repoFile.getName())
        print(COLOR_NORMAL, end='')

    print()
    print('Untracked')
    for repoFile in repository.getFilesUntracked():
        print(COLOR_FILE_UNTRACKED, end='')
        print(INDENT + repoFile.getName())
        print(COLOR_NORMAL, end='')

##----------------------------------------------------------------------------
## showRepositorySummary()
##      List all branches and show:
##          - First line:
##              - Branch/repository we'll be comparing to. Precedence is:
##                  - origin (if exists)
##                  - local dev (if exists and we're not dev)
##                  - local master (last resort, unless we're master)
##              - '*' if this is the current branch
##              - Branch Name
##                  - Make it bold face if it hasn't been merged into:
##                  - dev (if exists)
##                  - master (last resort)
##              - Flashing arrow if this is the current branch
##
##          - Following lines:
##              - Commits differing between the above branch/repository
##----------------------------------------------------------------------------
def showRepositorySummary(repository):
    global optionCurrentBranch
    global optionLong

    ##-------------------------------------------------------------------------
    ## We may be in detached head state
    ##-------------------------------------------------------------------------
    if repository.isDetachedHeadState():
        print(
            '\n' +
            COLOR_DETACHED_HEAD_STATE + 'Currently in detached head state' +
            COLOR_NORMAL
        )

    ##-------------------------------------------------------------------------
    ## Appropriate titles
    ##-------------------------------------------------------------------------
    print()

    if optionLong:
        print('Local Branches')
    else:
        print('Local Branches Commits Relative to Origin')

    print('Bold = not merged to dev (or master if no dev)')
    print()

    ##-------------------------------------------------------------------------
    ## One of:
    ##      - current branch (--current)
    ##      - manually selected branch (--branch xyz)
    ##      - all branches
    ##-------------------------------------------------------------------------
    if optionCurrentBranch:
        if optionLong:
            showBranchSummaryFull(repository.getCurrentBranch())
        else:
            showBranchSummaryShort(repository.getCurrentBranch())

    elif optionBranch != '':
        if optionLong:
            showBranchSummaryFull(repository.getBranch(optionBranch))
        else:
            showBranchSummaryShort(repository.getBranch(optionBranch))

    else:
        for branch in repository.getBranchHierarchy():
            if optionLong:
                showBranchSummaryFull(branch)
            else:
                showBranchSummaryShort(branch)

##----------------------------------------------------------------------------
## showStashSummary()
##      List all the stashes nicely
##----------------------------------------------------------------------------
def showStashSummary(repository):
    INDENT1 = '    '
    INDENT2 = INDENT1 + '          '

    print()
    print('Stashes')

    i = 0

    for stash in repository.getStashes():
        if i != 0:
            print()

        print(COLOR_STASH_NAME, end='')
        print(INDENT1 + stash.getName())
        print(COLOR_NORMAL, end='')
        print(padOrTruncate(INDENT2 + stash.getDescription(), 79))

##----------------------------------------------------------------------------
##----------------------------------------------------------------------------
main()
