#!/usr/bin/python3

##  This program is free software: you can redistribute it and/or modify
##  it under the terms of the GNU General Public License, version 3,
##  as published by the Free Software Foundation.
##
##  This program is distributed in the hope that it will be useful,
##  but WITHOUT ANY WARRANTY; without even the implied warranty of
##  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
##  GNU General Public License for more details.
##
##  You should have received a copy of the GNU General Public License
##  along with this program.  If not, see <http://www.gnu.org/licenses/>.

import os
import subprocess
import sys

BLANKS = '                                                                    '

TEXT_BOLD = 'bold'
TEXT_FLASHING = 'flashing'
TEXT_GREEN = 'green'
TEXT_MAGENTA = 'magenta'
TEXT_NORMAL = 'normal'
TEXT_YELLOW = 'yellow'
TEXT_RED = 'red'

ANSI_NORMAL   = '0'
ANSI_BOLD     = '1'
ANSI_FLASHING = '5'

ANSI_GREEN    = '32'
ANSI_MAGENTA  = '35'
ANSI_RED      = '31'
ANSI_WHITE    = '37'
ANSI_YELLOW   = '33'

COLOR_CURRENT_BRANCH       = '\033[' + ANSI_MAGENTA + 'm'
COLOR_DETACHED_HEAD_STATE  = '\033[' + ANSI_BOLD + 'm'
COLOR_ERROR                = '\033[' + ANSI_RED + 'm'
COLOR_FILE_MODIFIED        = '\033[' + ANSI_RED + 'm'
COLOR_FILE_STAGED          = '\033[' + ANSI_GREEN + 'm'
COLOR_FILE_UNTRACKED       = '\033[' + ANSI_YELLOW  + 'm'
COLOR_IMPORTANT_BRANCH     = '\033[' + ANSI_BOLD + ';' + ANSI_FLASHING + ';' + ANSI_MAGENTA + 'm'
COLOR_NORMAL               = '\033[' + ANSI_NORMAL + 'm'
COLOR_STASH_NAME           = '\033[' + ANSI_GREEN + 'm'
COLOR_UNMERGED_BRANCH_NAME = '\033[' + ANSI_BOLD + 'm'

##----------------------------------------------------------------------------
## Global vars
##----------------------------------------------------------------------------
optionBranch = ''
optionCurrentBranch = False
optionLocalCompareTo = ''
optionLog = False

class Branch:
    """
    A class used to represent one branch
    """

    def __init__(self, name, important, current, mergeTargetName):
        """
        Initialize this Branch
        Args
            name:                     str:  The name of the branch
            important:                bool: Whether this branch is "important"
                                            and needs to be flagged in output
            current:                  bool: Whether this is the current branch
            mergeTargetName:          str:  The name of the branch this one branch
                                            will merge to
        """

        self.name = name
        self.important = important
        self.current = current
        self.mergeTargetName = mergeTargetName

        ##---------------------------------------------------------------------
        ## Determine remote tracking branch (if it exists)
        ##---------------------------------------------------------------------
        try:
            remoteName = subprocess.check_output(
                [
                    'git',
                    'config',
                    'branch.' + name + '.remote'
                ],
                universal_newlines = True
            ).splitlines()

            self.remoteTrackingBranchName = remoteName[0] + '/' + name

        except:
            self.remoteTrackingBranchName = None

    def getCommitsNotIn(self, branchName):
        """
        Get a list of Commit objects for the commits that are in the current
        branch, but not in the specified branch
        :returns: list of Commit objects
        """

        commitHashes = subprocess.check_output(
            [
                'git',
                'rev-list',
                self.name,
                '^' + branchName
            ],
            universal_newlines = True
        ).splitlines()

        commits = []
        for hash in commitHashes:
            commits.append(Commit(hash))

        return commits

    def getCommitsOnlyIn(self, branchName):
        """
        Get a list of Commit objects for the commits that are in the specified
        branch, but not in the current branch
        :returns: list of Commit objects
        """

        commitHashes = subprocess.check_output(
            [
                'git',
                'rev-list',
                branchName,
                '^' + self.name
            ],
            universal_newlines = True
        ).splitlines()

        commits = []
        for hash in commitHashes:
            commits.append(Commit(hash))

        return commits
    def getMergeTargetName(self):
        """
        Get the name of the branch that this will eventually be merged to
        :returns: str
        """

        return self.mergeTargetName

    def getName(self):
        """
        Return this branch's name
        :returns: str
        """

        return self.name

    def getRemoteTrackingBranchName(self):
        """
        Return this branch's remote tracking branch name, possibly None
        :returns: str
        """

        return self.remoteTrackingBranchName

    def isCurrent(self):
        """
        Return this is the current branch
        :returns: bool
        """

        return self.current

    def isImportant(self):
        """
        Return this is an "important" branch
        :returns: bool
        """
        return self.important

class CommandBranch:
    """
    A class used for the branch subcommand
    """

    def __init__(self, scriptName, args):
        """
        Initialize this CommandBranch
        Args
            scriptName: str:         The name used to invoke this script
            args:       list of str: The user-specified command line args, excluding
                                     'branch'
        """

        self._processArgs(scriptName, args)
        self.repository = Repository()
        self.branch = self.repository.getCurrentBranch()

    def _processArgs(self, scriptName, args):
        """
        Process the user-specified command line args
        Args
            args: list of str: The user-specified command line args, excluding
                               'branch'
        """

        self.showTarget = False
        i = 0
        while i < len(args):
            if args[i] == '--target':
                self.showTarget = True

            else:
                print('Unknown commandline argument: ' + args[i])
                sys.exit()

            i += 1

    def run(self):
        """ Print the output for the 'branch' command """

        ##--------------------------------------------------------------------
        ## Branch name, remote, and merge target
        ##--------------------------------------------------------------------
        remote = self.branch.getRemoteTrackingBranchName()
        if remote == None:
            remote = 'None'

        mergeTarget = self.branch.getMergeTargetName()
        if mergeTarget == None:
            mergeTarget = 'None'

        print('Branch ' + formatText(TEXT_BOLD, self.branch.getName()))
        print('Remote ' + formatText(TEXT_BOLD, remote))
        print('Target ' + formatText(TEXT_BOLD, mergeTarget))

        ##--------------------------------------------------------------------
        ## Stashes
        ##--------------------------------------------------------------------
        print()
        stashes = FormatterStashes(self.repository.getStashes())
        printed = stashes.show()

        ##--------------------------------------------------------------------
        ## Staged, modified, untracked files
        ##--------------------------------------------------------------------
        if printed:
            print()

        files = FormatterFiles(
            self.repository.getFilesStaged(),
            self.repository.getFilesModified(),
            self.repository.getFilesUntracked(),
        )
        printed = files.show()

        ##--------------------------------------------------------------------
        ## Commits relative to remote
        ##--------------------------------------------------------------------
        remote = self.branch.getRemoteTrackingBranchName()
        if remote != None:
            printed = self._showCommitsAheadBehind(printed, remote)

        ##--------------------------------------------------------------------
        ## Commits relative to merge target
        ##--------------------------------------------------------------------
        if self.showTarget:
            mergeTarget = self.branch.getMergeTargetName()
            if mergeTarget != None:
                self._showCommitsAheadBehind(printed, mergeTarget)

    def _showCommitsAheadBehind(self, printSeparator, otherBranch):
        """
        Show the commits relative to the specified branch name

        Args:
            printSeparator: bool: Whether a blank separator should be printed
            otherBranch:    str:  The name of the other branch we're comparing to

        :returns: bool: Whether anything was printed
        """

        COLUMN_WIDTH = 38
        returnVal = False
        ##----------------------------------------------------------------
        ## Get commits to be printed
        ##----------------------------------------------------------------
        commitsAhead = self.branch.getCommitsNotIn(otherBranch)
        commitsBehind = self.branch.getCommitsOnlyIn(otherBranch)

        if len(commitsAhead) > 0 or len(commitsBehind) > 0:
            returnVal = True
            if printSeparator:
                print()

            title = padOrTruncate(self.branch.getName(), COLUMN_WIDTH)
            title += '  ' + otherBranch
            print(formatText(TEXT_BOLD, title))

            aheadIndex = 0
            behindIndex = 0

            while (aheadIndex < len(commitsAhead) or
                  behindIndex < len(commitsBehind)):

                if aheadIndex < len(commitsAhead):
                    text = commitsAhead[aheadIndex].getDescription()
                    output = padOrTruncate(text, COLUMN_WIDTH)
                    aheadIndex += 1
                else:
                    output = BLANKS[:COLUMN_WIDTH]

                if behindIndex < len(commitsBehind):
                    text = commitsBehind[behindIndex].getDescription()
                    output += '  ' + padOrTruncate(text, COLUMN_WIDTH)
                    behindIndex += 1

                print(output)

        return returnVal

class CommandRepo:
    """
    A class used for the repo subcommand
    """

    def __init__(self, scriptName, args):
        """
        Initialize this CommandRepo
        Args
            scriptName: str:         The name used to invoke this script
            args:       list of str: The user-specified command line args, excluding
                                     "repo"
        """

        self._processArgs(scriptName, args)
        self.repository = Repository()

    def _processArgs(self, scriptName, args):
        """
        Process the user-specified command line args
        Args
            args: list of str: The user-specified command line args after "repo"
        """

        if len(args) > 0:
            print('Usage: ' + scriptName + ' repo')

    def run(self):
        """ Print the output for the 'repo' command """

        stashes = FormatterStashes(self.repository.getStashes())
        printed = stashes.show()

        if printed:
            print()

        files = FormatterFiles(
            self.repository.getFilesStaged(),
            self.repository.getFilesModified(),
            self.repository.getFilesUntracked(),
        )
        printed = files.show()

        if printed:
            print()

        branches = FormatterBranches(
            self.repository.getBranchHierarchy(),
            self.repository.getBranches()
        )
        branches.show()

class Commit:
    """
    A class used to represent a commit
    """

    def __init__(self, hash):
        """
        Initialize this Commit
        Args
            hash: str: The hash for this particular commit
        """

        self.hash = hash

        ## Don't set description unless requested, because some commands
        ## don't need it, and performance takes a hit when lots of commits
        ## being processed
        self.description = None

    def getDescription(self):
        """
        Return the description for this commit
        :returns: str
        """

        if self.description == None:
            self._setDescription()

        return self.description

    def _setDescription(self):
        """
        Set self.description. This is intended to be called only by __init__()
        """
        gitShowOutput = subprocess.check_output(
            [
                'git',
                'show',
                '--no-patch',
                self.hash,
                '--pretty=oneline'
            ],
            universal_newlines = True
        ).splitlines()

        descriptionStart = gitShowOutput[0].find(' ') + 1
        self.description = gitShowOutput[0][descriptionStart:]

class FormatterBranches:
    """
    A class used to format a repository's branches
    """

    def __init__(self, branchHierarchy, branches):
        """
        Initialize this FormatterBranches
        Args
            branchHierarchy: list of Branch objects
            branches:        list of Branch objects: The list of branches
        """

        self.CURRENT_BRANCH_INDICATOR = '* '
        self.EMPTY_CURRENT_BRANCH_INDICATOR = '  '
        self.branchHierarchy = branchHierarchy
        self.branches = branches

    def getFormattedAheadBehind(self, prefix, num):
        """
        Use special criteria to return a string representation of num
        Args
            prefix: str: A string to prefix num with
            num:    int: The number to be prefixed

        :returns: str: See simple logic below
        """

        if num == -1:
            formattedNum = ''
        elif num == 0:
            formattedNum = '.'
        else:
            formattedNum = prefix + str(num)

        return formattedNum

    def show(self):
        """ Print the list of branches in hierarchical order """

        TITLE = '  Remote       Target  '  ## Need space for possibly 3 digit
        REF   = '+100  -100   +100  -100'  ## ahead/behind nums


        ##--------------------------------------------------------------------
        ## Determine the length of the branch name field so we can fit the
        ## remote and merge target information
        ##--------------------------------------------------------------------
        maxMergeTargetLen = 0
        for branch in self.branches:
            mergeTarget = branch.getMergeTargetName()
            targetLength = 0 if mergeTarget == None else len(mergeTarget)
            if targetLength > maxMergeTargetLen:
                maxMergeTargetLen = targetLength

        BRANCH_NAME_LEN = 79 - maxMergeTargetLen - 2 - len(TITLE) - 2
        BRANCH_NAME_LEN -= len(self.CURRENT_BRANCH_INDICATOR)

        ##--------------------------------------------------------------------
        ## Print the two title lines for remote and merge target ahead/behind
        ## info
        ##--------------------------------------------------------------------
        TITLE_PADDING = self.EMPTY_CURRENT_BRANCH_INDICATOR
        TITLE_PADDING += padOrTruncate(BLANKS, BRANCH_NAME_LEN)
        print(TITLE_PADDING + TITLE)

        ##--------------------------------------------------------------------
        ## Print the summary line for each branch, starting with the "important"
        ## branches (i.e. in hierarchical order)
        ##--------------------------------------------------------------------
        for branch in self.branchHierarchy:
            self._showShortSummary(BRANCH_NAME_LEN, branch)

    def _showShortSummary(self, branchNameLen, branch):
        """
        Show a one-line summary for the specified branch
        Args
            branchNameLen : int:    The length for branch names
            branch:         Branch: The Branch object to be printed
        """

        ##--------------------------------------------------------------------
        ## Determine what the current branch indicator should be:
        ##  - blank if not current branch
        ##  - '*' if it's the current branch
        ##  - flashing if it's important (i.e. dev or master)
        ##--------------------------------------------------------------------
        if branch.isCurrent():
            currentBranchIndicator = formatText(
                TEXT_MAGENTA,
                self.CURRENT_BRANCH_INDICATOR
            )
            if branch.isImportant():
                currentBranchIndicator = formatText(
                    TEXT_FLASHING,
                    currentBranchIndicator
                )
        else:
            currentBranchIndicator = self.EMPTY_CURRENT_BRANCH_INDICATOR

        ##--------------------------------------------------------------------
        ## Get count of commits ahead/behind of remote tracking branch
        ##--------------------------------------------------------------------
        remote = branch.getRemoteTrackingBranchName()
        numAheadRemote = -1
        numBehindRemote = -1

        if remote != None:
            numAheadRemote = len(branch.getCommitsNotIn(remote))
            numBehindRemote = len(branch.getCommitsOnlyIn(remote))

        ##--------------------------------------------------------------------
        ## Get count of commits ahead/behind of merge target
        ##--------------------------------------------------------------------
        mergeTarget = branch.getMergeTargetName()
        numAheadTarget = -1
        numBehindTarget = -1

        if mergeTarget != None:
            numAheadTarget = len(branch.getCommitsNotIn(mergeTarget))
            numBehindTarget = len(branch.getCommitsOnlyIn(mergeTarget))

        ##--------------------------------------------------------------------
        ## Create a string of the branch name and remote ahead/behind info
        ## so we can bold face it if required
        ##--------------------------------------------------------------------
        paddedBranchName = padOrTruncate(branch.getName(), branchNameLen)
        branchAndRemote = paddedBranchName

        branchAndRemote += rightJustify(
            self.getFormattedAheadBehind('+', numAheadRemote),
            4
        )
        branchAndRemote += '  '
        branchAndRemote += padOrTruncate(
            self.getFormattedAheadBehind('-', numBehindRemote),
            6
        )

        ##--------------------------------------------------------------------
        ## Bold face if the branch is out of sync with its remote
        ##--------------------------------------------------------------------
        if (numAheadRemote > 0 or numBehindRemote > 0):
           branchAndRemote = formatText(TEXT_BOLD, branchAndRemote)

        ##--------------------------------------------------------------------
        ## Build up the rest of the output line
        ##--------------------------------------------------------------------
        output = currentBranchIndicator + branchAndRemote
        output += '  '
        output += rightJustify(
            self.getFormattedAheadBehind('+', numAheadTarget),
            4
        )
        output += '  '
        output += padOrTruncate(
            self.getFormattedAheadBehind('-', numBehindTarget),
            6
        )

        if mergeTarget != None:
            output += ' ' + mergeTarget

        print(output)

class FormatterFiles:
    """
    A class used to format a repository's staged, modified, and untracked files
    """

    def __init__(self, stagedFiles, modifiedFiles, untrackedFiles):
        """
        Initialize this FormatterFiles
        Args
            stagedFiles:    list of RepositoryFile objects: The list of staged
                                                            files
            modifiedFiles:  list of RepositoryFile objects: The list of modified
                                                            files
            untrackedFiles: list of RepositoryFile objects: The list of untracked
                                                            files
        :returns: bool: Whether anything was printed
        """

        self.stagedFiles = stagedFiles
        self.modifiedFiles = modifiedFiles
        self.untrackedFiles = untrackedFiles

    def show(self):
        """ Print a staged, modified, and untracked files """

        TITLE_STAGED    = 'Staged   '
        TITLE_MODIFIED  = 'Modified '
        TITLE_UNTRACKED = 'Untracked'
        self.INDENT = BLANKS[0:len(TITLE_UNTRACKED)]

        returnVal = False

        ##--------------------------------------------------------------------
        ## Staged Files
        ##--------------------------------------------------------------------
        lines = []
        for oneFile in self.stagedFiles:
            formattedLine = formatText(
                TEXT_GREEN,
                oneFile.getIndexStatus() + ' ' + oneFile.getName()
            )

            lines.append(formattedLine)

        self.showBlock(TITLE_STAGED, lines)
        if len(lines) != 0:
            returnVal = True

        ##--------------------------------------------------------------------
        ## Modified Files
        ##--------------------------------------------------------------------
        lines = []
        for oneFile in self.modifiedFiles:
            formattedLine = formatText(
                TEXT_RED,
                oneFile.getWorkingTreeStatus() + ' ' + oneFile.getName()
            )

            lines.append(formattedLine)

        if len(lines) != 0:
            if len(self.modifiedFiles) != 0:
                print()

            self.showBlock(TITLE_MODIFIED, lines)
            returnVal = True

        ##--------------------------------------------------------------------
        ## Untracked Files
        ##--------------------------------------------------------------------
        lines = []
        for oneFile in self.untrackedFiles:
            formattedLine = formatText(TEXT_YELLOW, oneFile.getName())

            lines.append(formattedLine)

        if len(lines) != 0:
            if len(self.modifiedFiles) != 0:
                print()

            self.showBlock(TITLE_UNTRACKED, lines)
            returnVal = True

        return returnVal

    def showBlock(self, title, lines):
        """
        Print a block of lines with a title
        Args
            title: str:         The title for this block of lines
            lines: list of str: The list of lines to be printed
        """

        first = True
        for line in lines:
            lead = title if first else self.INDENT
            first = False

            print(lead + ' ' + line)

class FormatterStashes:
    """
    A class used to format a repository's staged, modified, and untracked files
    """

    def __init__(self, stashes):
        """
        Initialize this FormatterStashes
        Args
            stashes: list of Stash objects: The list of stashes to be printed

        :returns: bool: Whether anything was printed
        """

        self.stashes = stashes

    def show(self):
        """ Print a list of stashes """

        TITLE = 'Stashes  '
        INDENT = BLANKS[0:len(TITLE)]

        first = True
        for stash in self.stashes:
            lead = TITLE if first else INDENT
            first = False

            stashName = stash.getName()

            output = lead + ' '
            output += formatText(TEXT_GREEN, stashName)
            output += ' '
            output += padOrTruncate(
                stash.getDescription(),
                77 - len(lead + stashName)
            )

            print(output)

        ## Return whether anything was printed
        return not first

class Repository:
    """
    A class used to represent the git repository contained in the current
    working directory
    """

    def __init__(self):
        """ Initialize git info corresponding to current directory """

        ## "Important" branches that should be flagged in output
        self.IMPORTANT_BRANCHES = ['dev', 'master']

        ## A mapping of branches to their corresponding merge targets
        self.MERGE_TARGETS = {
            'default': 'dev',
            'noTarget': ['master'],
            'targets': {
                'dev': 'master'
            }
        }


        self.branches = []
        self.branchNames = []
        self.currentBranch= None
        self.detachedHeadState = False
        self.filesModified = []
        self.filesStaged = []
        self.filesUntracked = []
        self.stashes = []

        self.ensureGitTrackedFolder()
        self._populateBranchInfo()
        self._populateFilesInfo()
        self._populateStashInfo()

    def ensureGitTrackedFolder(self):
        """ Ensure this is a git-tracked folder """

        try:
            gitOutput = subprocess.check_output(
                ['git', 'status'],
                stderr=subprocess.STDOUT
            )
        except:
            print("This isn't a git tracked folder.")
            exit()

    def getBranch(self, branchName):
        """
        Return the Branch object whose name is branchName
        :returns: Branch The Branch object
        """

        for branch in self.branches:
            if branch.getName() == branchName:
                return branch

        return None

    def getBranches(self):
        """
        Return a List of the (local) branches
        :returns: list of Branch objects
        """

        return self.branches

    def getBranchHierarchy(self):
        """
        Return a list of Branch objects in the following order:
            - Branches with no merge target
            - Branches whose merge targets have been specified
            - Other branches
        :returns: list of Branch objects
        """

        branchList = self.MERGE_TARGETS['noTarget']
        branchList += self.MERGE_TARGETS['targets'].keys()

        for branch in self.branchNames:
            if branch not in branchList:
                branchList.append(branch)

        returnVal = []
        for branchName in branchList:
            branch = self.getBranch(branchName)
            if branch != None:
                returnVal.append(branch)

        return returnVal

    def getCurrentBranch(self):
        """
        Return the current branch
        :returns: Branch
        """

        return self.currentBranch

    def getFilesModified(self):
        """
        Get a list of this repository's modified files
        :returns: list of str
        """

        return self.filesModified

    def getFilesStaged(self):
        """
        Get a list of this repository's staged files
        :returns: list of str
        """

        return self.filesStaged

    def getFilesUntracked(self):
        """
        Get a list of this repository's untracked files
        :returns: list of str
        """

        return self.filesUntracked

    def getMergeTargetName(self, branchName):
        """
        Return the name of the branch that branchName will merge to
        :returns: str
        """

        if (branchName in self.MERGE_TARGETS['noTarget']):
            returnVal = None
        elif (branchName in self.MERGE_TARGETS['targets']):
            returnVal = self.MERGE_TARGETS['targets'][branchName]
        else:
            returnVal = self.MERGE_TARGETS['default']

        return returnVal

    def getStashes(self):
        """
        Return a list of Stash objects
        :returns: list of STash objects
        """

        return self.stashes

    def isDetachedHeadState(self):
        """
        Return whether the git repository is in "detached head state"
        :returns: bool
        """

        return self.detachedHeadState

    def _populateBranchInfo(self):
        """
        Populate the information about this repository's branches.
        This is intended to be called only by __init__()
        """

        branchesOutput = subprocess.check_output(
            ['git', 'branch', '--list', '-vv'],
            universal_newlines = True
        ).splitlines()

        for branchOutputLine in branchesOutput:
            isCurrentBranch = False
            remoteTrackingBranchName = None

            branchNameStart = 2
            branchNameEnd = branchOutputLine.index(' ', 2)
            branchName = branchOutputLine[branchNameStart : branchNameEnd]

            self.detachedHeadState = (branchName.startswith('(detached'))

            if not self.detachedHeadState:
                if branchOutputLine[0] == '*':
                    isCurrentBranch = True

                ##-------------------------------------------------------------
                ## Create the new branch object
                ##-------------------------------------------------------------
                isImportant = False
                if branchName in self.IMPORTANT_BRANCHES:
                    isImportant = True

                newBranch = Branch(
                    branchName,
                    isImportant,
                    isCurrentBranch,
                    self.getMergeTargetName(branchName)
                )

                ## Assign some stuff that can only be done after branch object
                ## creation
                self.branches.append(newBranch)
                self.branchNames.append(newBranch.getName())
                if isCurrentBranch:
                    self.currentBranch = newBranch

    def _populateFilesInfo(self):
        """
        Populate the information about this repository's files
        (staged, modified, and untracked).
        This is intended to be called only by __init__()
        """

        gitStatusOutput = subprocess.check_output(
            ['git', 'status', '--porcelain'],
            universal_newlines = True
        ).splitlines()

        for line in gitStatusOutput:
            indexStatus = line[0]
            workingTreeStatus = line[1]
            fileName = line[3:]

            newRepositoryFile = RepositoryFile(
                fileName,
                indexStatus,
                workingTreeStatus
            )

            if indexStatus != ' ' and indexStatus != '?':
                self.filesStaged.append(newRepositoryFile)

            if workingTreeStatus != ' ' and workingTreeStatus != '?':
                self.filesModified.append(newRepositoryFile)

            if indexStatus == '?':
                self.filesUntracked.append(newRepositoryFile)

    def _populateStashInfo(self):
        """
        Populate the information about this repository's stashes.
        This is intended to be called only by __init__()
        """

        stashesOutput = subprocess.check_output(
            ['git', 'stash', 'list'],
            universal_newlines = True
        ).splitlines()

        for stashLine in stashesOutput:
            nameEnd = stashLine.find(':')
            newStash = Stash(stashLine[:nameEnd], stashLine[nameEnd+2:])
            self.stashes.append(newStash)

class RepositoryFile:
    """
    A class used to represent a staged, modified, or untracked file in
    the current git repository
    """

    def __init__(self, name, indexStatus, workingTreeStatus):
        """
        Initialize this RepositoryFile
        Args
            name:             str: The name of this file
            indexStatus       str: The one-character index status of this file
            workingTreeStatus str: The one-character working tree status of this file
        """
        self.name = name
        self.indexStatus = indexStatus
        self.workingTreeStatus = workingTreeStatus

    def getIndexStatus(self):
        """
        Get the one-character index status of this file
        :returns: str
        """

        return self.indexStatus

    def getName(self):
        """
        Get the fully qualified name of this file
        :returns: str
        """

        return self.name

    def getWorkingTreeStatus(self):
        """
        Get the one-character working tree status of this file
        :returns: str
        """

        return self.workingTreeStatus

class Stash:
    """
    A class used to represent one stash
    """

    def __init__(self, name, description):
        """ Initialize a stash """

        self.name = name
        self.description = description

    def getDescription(self):
        """
        Return the description of this stash
        :returns: str
        """
        return self.description

    def getName(self):
        """
        Return the name of this stash
        :returns: str
        """

        return self.name

def centerText(text, width):
    padLength = round((width - len(text)) / 2)
    centeredText = BLANKS[:padLength] + text

    return padOrTruncate(centeredText, width)

def formatText(style, text):
    """
    Print the specified text in the specified style
    Args
        style: str: One of the global TEXT_* constants
        text:  str: The text to print
    """

    ESCAPE_MAPPING = {
        TEXT_BOLD: '1',
        TEXT_FLASHING: '5',
        TEXT_GREEN: '32',
        TEXT_MAGENTA: '35',
        TEXT_NORMAL: '0',
        TEXT_RED: '31',
        TEXT_YELLOW: '33'
    }

    escapeStart = '\033[' + ESCAPE_MAPPING[style] + 'm'
    escapeEnd = '\033[' + ESCAPE_MAPPING[TEXT_NORMAL] + 'm'

    return escapeStart + text + escapeEnd

##----------------------------------------------------------------------------
## main()
##      Drive the whole process
##----------------------------------------------------------------------------
def main():
    if (len(sys.argv) > 1):
        if sys.argv[1] == 'repo':
            cmdRepo = CommandRepo(sys.argv[0], sys.argv[2:])
            cmdRepo.run()

        elif sys.argv[1] == 'branch':
            cmdBranch = CommandBranch(sys.argv[0], sys.argv[2:])
            cmdBranch.run()

        else:
            processCommandLineArgs(sys.argv)

            repository = Repository()

            showFilesSummary(repository)
            showStashSummary(repository)
            showRepositorySummary(repository)

    else:
        processCommandLineArgs(sys.argv)

        repository = Repository()

        showFilesSummary(repository)
        showStashSummary(repository)
        showRepositorySummary(repository)

##----------------------------------------------------------------------------
## padOrTruncate(text, length)
##      - Pad or truncate the specified string to return one of the exact
##        specified length
##----------------------------------------------------------------------------
def padOrTruncate(text, length):
    returnVal = text

    if (len(text) < length):
        formatString = '{{:<{}}}'.format(str(length))
        returnVal = formatString.format(text)

    elif (len(text) > length):
        returnVal = text[0:length]

    return returnVal

##----------------------------------------------------------------------------
## processCommandLineArgs
##      Set options variables based on command line arguments
##----------------------------------------------------------------------------
def processCommandLineArgs(args):
    global optionBranch
    global optionCurrentBranch
    global optionLocalCompareTo
    global optionLong

    optionBranch         = ''
    optionCurrentBranch  = False
    optionLocalCompareTo = ''
    optionLong           = False

    i = 1
    while i < len(args):
        if args[i] == '--branch':
            optionLong = True
            optionBranch = args[i+1]
            i += 1

        elif args[i] == '--compareto':
            optionLocalCompareTo = args[i+1]
            i += 1

        elif args[i] == '--current':
            optionCurrentBranch = True
            optionLong = True

        elif args[i] == '--long':
            optionLong = True

        elif args[i] == '--short':
            optionLong = False

        elif args[i] == '--version':
            print(args[0] + ' - Version 2017-02-14a')
            sys.exit()

        elif args[i] == '--help':
            print('Usage: ' + args[0])
            print('    --branch NAME    - Show only the specified branch. Implies --long')
            print('    --compareto NAME - Compare to the specified local branch rather')
            print('                       than dev/master')
            print('    --current        - Show only the current branch. Implies --long')
            print('    --long           - Also show commits that differ between branch')
            print('                       and dev (or master if dev does\'t exist)')
            print('    --short          - Do not show commits that differ between branch and')
            print('                       dev (or master if dev does\'t exist)')
            print('                       This is the default when --current is not specified')
            sys.exit()

        else:
            print('Unknown commandline argument:')
            print('    ' + args[i])
            sys.exit()

        i += 1

def rightJustify(text, width):
    padLength = width - len(text)
    justifiedText = BLANKS[:padLength] + text

    return justifiedText

##----------------------------------------------------------------------------
## showBranchSummaryShort
##      Show a short summary of the specified branch. This consists of:
##          One line with:
##              - '*' if the branch is the current one checked out
##              - The branch name--bold if it is ahead of local dev/master
##              - 'Ahead', and/or 'Behind' if it's ahead and/or behind of
##                dev/master
##              - 'dev' or 'master', depending on which branch we're comparing to
##
##          A list of commits that are ahead/behind of this branch's origin
##----------------------------------------------------------------------------
def showBranchSummaryShort(branch):
    BRANCH_NAME_LENGTH = 54
    INDENT = '        '
    COMMIT_LENGTH = 79 - len(INDENT)

    branchName = branch.getName()
    mergeTargetName = branch.getMergeTargetName()

    ##--------------------------------------------------------------------
    ## Figure out if we have a corresponding branch in origin
    ##--------------------------------------------------------------------
    remoteTrackingBranchName = branch.getRemoteTrackingBranchName()

    ##--------------------------------------------------------------------
    ## Get commits ahead/behind of origin
    ##--------------------------------------------------------------------
    commitsBehindOrigin = []
    commitsAheadOfOrigin = []

    if remoteTrackingBranchName != None:
        for commit in branch.getCommitsNotIn(remoteTrackingBranchName):
            commitsAheadOfOrigin.append('+ ' + commit.getDescription())

        for commit in branch.getCommitsOnlyIn(remoteTrackingBranchName):
            commitsBehindOrigin.append('- ' + commit.getDescription())

    ##--------------------------------------------------------------------
    ## Get commits ahead/behind of merge target
    ##--------------------------------------------------------------------
    commitsBehindMergeTarget = []
    commitsAheadOfMergeTarget = []

    if mergeTargetName != None:
        for commit in branch.getCommitsNotIn(mergeTargetName):
            commitsAheadOfMergeTarget.append('+ ' + commit.getDescription())

        for commit in branch.getCommitsOnlyIn(mergeTargetName):
            commitsBehindMergeTarget.append('- ' + commit.getDescription())

    ##--------------------------------------------------------------------
    ## Combine our lists by column
    ##--------------------------------------------------------------------
    commitsRelativeToOrigin = commitsBehindOrigin + commitsAheadOfOrigin
    commitsRelativeToMergeTarget = commitsBehindMergeTarget + commitsAheadOfMergeTarget

    ##--------------------------------------------------------------------
    ## Formatted Branch Name
    ##--------------------------------------------------------------------
    currentBranchIndicator = ' '
    if branch.isCurrent():
        if branch.isImportant():
            currentBranchIndicator = COLOR_IMPORTANT_BRANCH + '*' + COLOR_NORMAL
        else:
            currentBranchIndicator = COLOR_CURRENT_BRANCH + '*' + COLOR_NORMAL

    ##--------------------------------------------------------------------
    ## Ahead / behind of merge target
    ##--------------------------------------------------------------------
    ahead = '-----'
    if len(commitsAheadOfMergeTarget) != 0:
        ahead = 'Ahead'

    behind = '------'
    if len(commitsBehindMergeTarget) != 0:
        behind = 'Behind'

    ##--------------------------------------------------------------------
    ## Print branchname line
    ##--------------------------------------------------------------------
    if len(commitsRelativeToOrigin) > 0:
        print()

    outputString = currentBranchIndicator + ' '

    if len(commitsAheadOfMergeTarget) != 0:
        outputString += COLOR_UNMERGED_BRANCH_NAME
        outputString += padOrTruncate(branchName, BRANCH_NAME_LENGTH) + ' '
        outputString += COLOR_NORMAL

    else:
        outputString += padOrTruncate(branchName, BRANCH_NAME_LENGTH) + ' '

    outputString += padOrTruncate(ahead, 7) + ' '
    outputString += padOrTruncate(behind, 7) + ' '

    if mergeTargetName != None:
        outputString += mergeTargetName

    print(outputString)

    ##--------------------------------------------------------------------
    ## Print commits relative to origin
    ##--------------------------------------------------------------------
    for commit in commitsRelativeToOrigin:
        outputString = INDENT + padOrTruncate(commit, COMMIT_LENGTH)

        print(outputString)

    if len(commitsRelativeToOrigin) != 0:
        print()

##----------------------------------------------------------------------------
## showBranchSummaryFull
##      Show a full summary of the specified branch. This consists of:
##          One line with:
##              - '*' if the branch is the current one checked out
##              - The branch name--bold if it is ahead of local dev/master
##              - 'Ahead', and/or 'Behind' if it's ahead and/or behind of
##                dev/master
##              - 'dev' or 'master', depending on which branch we're comparing to
##
##          One column listing commits ahead/behind of this branch's origin
##          One column listing commits ahead/behind of dev/master
##----------------------------------------------------------------------------
def showBranchSummaryFull(branch):
    INDENT = '        '
    COMMIT_LENGTH = 60

    branchName = branch.getName()
    mergeTargetName = branch.getMergeTargetName()

    ##--------------------------------------------------------------------
    ## Figure out if we have a corresponding branch in origin
    ##--------------------------------------------------------------------
    remoteTrackingBranchName = branch.getRemoteTrackingBranchName()

    ##--------------------------------------------------------------------
    ## Get commits ahead/behind of origin
    ##--------------------------------------------------------------------
    commitsBehindOrigin = []
    commitsAheadOfOrigin = []

    ##--------------------------------------------------------------------
    ## Get commits ahead/behind of origin
    ##--------------------------------------------------------------------
    commitsBehindOrigin = []
    commitsAheadOfOrigin = []

    if remoteTrackingBranchName != None:
        for commit in branch.getCommitsNotIn(remoteTrackingBranchName):
            commitsAheadOfOrigin.append('+ ' + commit.getDescription())

        for commit in branch.getCommitsOnlyIn(remoteTrackingBranchName):
            commitsBehindOrigin.append('- ' + commit.getDescription())

    ##--------------------------------------------------------------------
    ## Get commits ahead/behind of merge target
    ##--------------------------------------------------------------------
    commitsBehindMergeTarget = []
    commitsAheadOfMergeTarget = []

    if mergeTargetName != None:
        for commit in branch.getCommitsNotIn(mergeTargetName):
            commitsAheadOfMergeTarget.append('+ ' + commit.getDescription())

        for commit in branch.getCommitsOnlyIn(mergeTargetName):
            commitsBehindMergeTarget.append('- ' + commit.getDescription())

    ##--------------------------------------------------------------------
    ## Combine our lists by column
    ##--------------------------------------------------------------------
    commitsRelativeToOrigin = commitsBehindOrigin + commitsAheadOfOrigin
    commitsRelativeToMergeTarget = commitsBehindMergeTarget + commitsAheadOfMergeTarget

    ##--------------------------------------------------------------------
    ## Formatted Branch Name
    ##--------------------------------------------------------------------
    currentBranchIndicator = ' '
    if branch.isCurrent():
        currentBranchIndicator = COLOR_CURRENT_BRANCH + '*' + COLOR_NORMAL

    formattedBranchName = branchName
    if len(commitsAheadOfMergeTarget) != 0:
        formattedBranchName =COLOR_UNMERGED_BRANCH_NAME + branchName + COLOR_NORMAL

    ##--------------------------------------------------------------------
    ## Print branchname line
    ##--------------------------------------------------------------------
    print(currentBranchIndicator + ' ' + formattedBranchName)

    ##--------------------------------------------------------------------
    ## Commits differing between origin and/or mergeTarget
    ##--------------------------------------------------------------------
    if len(commitsRelativeToOrigin) > 0 or len(commitsRelativeToMergeTarget) > 0:
        outputLine = INDENT
        outputLine += padOrTruncate('Relative to Origin', COMMIT_LENGTH) + '  '
        outputLine += padOrTruncate(
            'Relative to ' + mergeTargetName,
            COMMIT_LENGTH
        )
        print(outputLine)

        indexOrigin = 0
        indexMergeTarget = 0

        while (indexOrigin < len(commitsRelativeToOrigin) or
               indexMergeTarget < len(commitsRelativeToMergeTarget)):

            outputLine = INDENT
            if indexOrigin < len(commitsRelativeToOrigin):
                outputLine += padOrTruncate(
                    commitsRelativeToOrigin[indexOrigin],
                    COMMIT_LENGTH
                )
                indexOrigin += 1
            else:
                outputLine += padOrTruncate('', COMMIT_LENGTH)

            if indexMergeTarget < len(commitsRelativeToMergeTarget):
                outputLine += '  '
                outputLine += padOrTruncate(
                    commitsRelativeToMergeTarget[indexMergeTarget],
                    COMMIT_LENGTH
                )
                indexMergeTarget += 1

            print(outputLine)

##----------------------------------------------------------------------------
## showFilesSummary()
##      Summarize the following for the current branch:
##          Staged changes
##          Unstaged changes
##          Untracked files
##----------------------------------------------------------------------------
def showFilesSummary(repository):
    INDENT = '           '

    print('Staged')
    for repoFile in repository.getFilesStaged():
        print(COLOR_FILE_STAGED, end='')
        print(INDENT + repoFile.getIndexStatus() + ' ' + repoFile.getName())
        print(COLOR_NORMAL, end='')

    print()
    print('Modified')
    for repoFile in repository.getFilesModified():
        print(COLOR_FILE_MODIFIED, end='')
        print(INDENT + repoFile.getWorkingTreeStatus() + ' ' + repoFile.getName())
        print(COLOR_NORMAL, end='')

    print()
    print('Untracked')
    for repoFile in repository.getFilesUntracked():
        print(COLOR_FILE_UNTRACKED, end='')
        print(INDENT + repoFile.getName())
        print(COLOR_NORMAL, end='')

##----------------------------------------------------------------------------
## showRepositorySummary()
##      List all branches and show:
##          - First line:
##              - Branch/repository we'll be comparing to. Precedence is:
##                  - origin (if exists)
##                  - local dev (if exists and we're not dev)
##                  - local master (last resort, unless we're master)
##              - '*' if this is the current branch
##              - Branch Name
##                  - Make it bold face if it hasn't been merged into:
##                  - dev (if exists)
##                  - master (last resort)
##              - Flashing arrow if this is the current branch
##
##          - Following lines:
##              - Commits differing between the above branch/repository
##----------------------------------------------------------------------------
def showRepositorySummary(repository):
    global optionCurrentBranch
    global optionLong

    ##-------------------------------------------------------------------------
    ## We may be in detached head state
    ##-------------------------------------------------------------------------
    if repository.isDetachedHeadState():
        print(
            '\n' +
            COLOR_DETACHED_HEAD_STATE + 'Currently in detached head state' +
            COLOR_NORMAL
        )

    ##-------------------------------------------------------------------------
    ## Appropriate titles
    ##-------------------------------------------------------------------------
    print()

    if optionLong:
        print('Local Branches')
    else:
        print('Local Branches Commits Relative to Origin')

    print('Bold = not merged to dev (or master if no dev)')
    print()

    ##-------------------------------------------------------------------------
    ## One of:
    ##      - current branch (--current)
    ##      - manually selected branch (--branch xyz)
    ##      - all branches
    ##-------------------------------------------------------------------------
    if optionCurrentBranch:
        if optionLong:
            showBranchSummaryFull(repository.getCurrentBranch())
        else:
            showBranchSummaryShort(repository.getCurrentBranch())

    elif optionBranch != '':
        if optionLong:
            showBranchSummaryFull(repository.getBranch(optionBranch))
        else:
            showBranchSummaryShort(repository.getBranch(optionBranch))

    else:
        for branch in repository.getBranchHierarchy():
            if optionLong:
                showBranchSummaryFull(branch)
            else:
                showBranchSummaryShort(branch)

##----------------------------------------------------------------------------
## showStashSummary()
##      List all the stashes nicely
##----------------------------------------------------------------------------
def showStashSummary(repository):
    INDENT1 = '    '
    INDENT2 = INDENT1 + '          '

    print()
    print('Stashes')

    i = 0

    for stash in repository.getStashes():
        if i != 0:
            print()

        print(COLOR_STASH_NAME, end='')
        print(INDENT1 + stash.getName())
        print(COLOR_NORMAL, end='')
        print(padOrTruncate(INDENT2 + stash.getDescription(), 79))

##----------------------------------------------------------------------------
##----------------------------------------------------------------------------
main()
