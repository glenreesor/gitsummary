#!/usr/bin/python3

##  This program is free software: you can redistribute it and/or modify
##  it under the terms of the GNU General Public License, version 3,
##  as published by the Free Software Foundation.
##
##  This program is distributed in the hope that it will be useful,
##  but WITHOUT ANY WARRANTY; without even the implied warranty of
##  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
##  GNU General Public License for more details.
##
##  You should have received a copy of the GNU General Public License
##  along with this program.  If not, see <http://www.gnu.org/licenses/>.

import os
import re
import subprocess
import sys

BLANKS = '                                                                    '

TEXT_BOLD = 'bold'
TEXT_FLASHING = 'flashing'
TEXT_GREEN = 'green'
TEXT_MAGENTA = 'magenta'
TEXT_NORMAL = 'normal'
TEXT_YELLOW = 'yellow'
TEXT_RED = 'red'

class Branch:
    """
    A class used to represent one branch
    """

    def __init__(self, name, important, current, mergeTargetName):
        """
        Initialize this Branch
        Args
            name:                     str:  The name of the branch
            important:                bool: Whether this branch is "important"
                                            and needs to be flagged in output
            current:                  bool: Whether this is the current branch
            mergeTargetName:          str:  The name of the branch this one branch
                                            will merge to
        """

        self.name = name
        self.important = important
        self.current = current
        self.mergeTargetName = mergeTargetName

        ##---------------------------------------------------------------------
        ## Determine remote tracking branch (if it exists)
        ##---------------------------------------------------------------------
        try:
            remoteName = subprocess.check_output(
                [
                    'git',
                    'config',
                    'branch.' + name + '.remote'
                ],
                universal_newlines = True
            ).splitlines()

            self.remoteTrackingBranchName = remoteName[0] + '/' + name

        except:
            self.remoteTrackingBranchName = None

    def getCommitsNotIn(self, branchName):
        """
        Get a list of Commit objects for the commits that are in the current
        branch, but not in the specified branch
        :returns: list of Commit objects
        """

        commitHashes = subprocess.check_output(
            [
                'git',
                'rev-list',
                self.name,
                '^' + branchName
            ],
            universal_newlines = True
        ).splitlines()

        commits = []
        for hash in commitHashes:
            commits.append(Commit(hash))

        return commits

    def getCommitsOnlyIn(self, branchName):
        """
        Get a list of Commit objects for the commits that are in the specified
        branch, but not in the current branch
        :returns: list of Commit objects
        """

        commitHashes = subprocess.check_output(
            [
                'git',
                'rev-list',
                branchName,
                '^' + self.name
            ],
            universal_newlines = True
        ).splitlines()

        commits = []
        for hash in commitHashes:
            commits.append(Commit(hash))

        return commits
    def getMergeTargetName(self):
        """
        Get the name of the branch that this will eventually be merged to
        :returns: str
        """

        return self.mergeTargetName

    def getName(self):
        """
        Return this branch's name
        :returns: str
        """

        return self.name

    def getRemoteTrackingBranchName(self):
        """
        Return this branch's remote tracking branch name, possibly None
        :returns: str
        """

        return self.remoteTrackingBranchName

    def isCurrent(self):
        """
        Return this is the current branch
        :returns: bool
        """

        return self.current

    def isImportant(self):
        """
        Return this is an "important" branch
        :returns: bool
        """
        return self.important

class CommandBranch:
    """
    A class used for the branch subcommand
    """

    def __init__(self, scriptName, args):
        """
        Initialize this CommandBranch
        Args
            scriptName: str:         The name used to invoke this script
            args:       list of str: The user-specified command line args, excluding
                                     'branch'
        """

        self.screenWidth = 80
        self._processArgs(scriptName, args)
        self.repository = Repository()
        self.branch = self.repository.getCurrentBranch()

    def _processArgs(self, scriptName, args):
        """
        Process the user-specified command line args
        Args
            args: list of str: The user-specified command line args, excluding
                               'branch'
        """

        self.showTarget = False
        i = 0
        while i < len(args):
            if args[i] == '--target':
                self.showTarget = True

            elif re.match('^--[0-9]+$', args[i]):
                self.screenWidth = int(args[i][2:])

            else:
                print('Unknown commandline argument: ' + args[i])
                sys.exit()

            i += 1

    def run(self):
        """ Print the output for the 'branch' command """

        ##--------------------------------------------------------------------
        ## Branch name, remote, and merge target
        ##--------------------------------------------------------------------
        remote = self.branch.getRemoteTrackingBranchName()
        if remote == None:
            remote = 'None'

        mergeTarget = self.branch.getMergeTargetName()
        if mergeTarget == None:
            mergeTarget = 'None'

        print('Branch ' + formatText(TEXT_BOLD, self.branch.getName()))
        print('Remote ' + formatText(TEXT_BOLD, remote))
        print('Target ' + formatText(TEXT_BOLD, mergeTarget))

        ##--------------------------------------------------------------------
        ## Stashes
        ##--------------------------------------------------------------------
        print()
        stashes = FormatterStashes(self.repository.getStashes())
        printed = stashes.show()

        ##--------------------------------------------------------------------
        ## Staged, modified, untracked files
        ##--------------------------------------------------------------------
        if printed:
            print()

        files = FormatterFiles(
            self.repository.getFilesStaged(),
            self.repository.getFilesModified(),
            self.repository.getFilesUntracked(),
        )
        printed = files.show()

        ##--------------------------------------------------------------------
        ## Commits relative to remote
        ##--------------------------------------------------------------------
        remote = self.branch.getRemoteTrackingBranchName()
        if remote != None:
            printed = self._showCommitsAheadBehind(
                          printed,
                          True,
                          'Remote',
                          remote
                      )

        ##--------------------------------------------------------------------
        ## Commits relative to merge target
        ##--------------------------------------------------------------------
        mergeTarget = self.branch.getMergeTargetName()
        if mergeTarget != None:
            self._showCommitsAheadBehind(
                printed,
                self.showTarget,
                'Target',
                mergeTarget
            )

    def _showCommitsAheadBehind(self, printSeparator, showAllCommits, otherBranchTitle, otherBranch):
        """
        Show the commits relative to the specified branch name

        Args:
            printSeparator: bool: Whether a blank separator should be printed
            showAllCommits: bool: Whether to show all differing commits (True)
                                  or just number of differing ommits (False)
            title:          str:  The title to use for the other branch
            otherBranch:    str:  The name of the other branch we're comparing to

        :returns: bool: Whether anything was printed
        """

        COLUMN_WIDTH = round(self.screenWidth / 2) - 1
        returnVal = False
        ##----------------------------------------------------------------
        ## Get commits to be printed
        ##----------------------------------------------------------------
        commitsAhead = self.branch.getCommitsNotIn(otherBranch)
        commitsBehind = self.branch.getCommitsOnlyIn(otherBranch)

        if len(commitsAhead) > 0 or len(commitsBehind) > 0:
            returnVal = True
            if printSeparator:
                print()

            title = padOrTruncate('Local Branch', COLUMN_WIDTH)
            title += '  ' + otherBranchTitle
            print(formatText(TEXT_BOLD, title))

            if not showAllCommits:
                ##-------------------------------------------------------------
                ## Only show the number of commits differing between this branch
                ## and the specified one branch
                ##-------------------------------------------------------------
                if len(commitsAhead) == 1:
                    output = '1 commit'
                elif len(commitsAhead) > 1:
                    output = str(len(commitsAhead)) + ' commits'
                else:
                    output = ''

                output = padOrTruncate(output, COLUMN_WIDTH) + '  '

                if len(commitsBehind) == 1:
                    output += '1 commit'
                elif len(commitsBehind) > 1:
                    output += str(len(commitsBehind)) + ' commits'

                print(output)

            else:
                ##-------------------------------------------------------------
                ## Show description of each commit differing between this branch
                ## and the specified one branch
                ##-------------------------------------------------------------
                aheadIndex = 0
                behindIndex = 0

                while (aheadIndex < len(commitsAhead) or
                      behindIndex < len(commitsBehind)):

                    if aheadIndex < len(commitsAhead):
                        text = commitsAhead[aheadIndex].getDescription()
                        output = padOrTruncate(text, COLUMN_WIDTH)
                        aheadIndex += 1
                    else:
                        output = BLANKS[:COLUMN_WIDTH]

                    if behindIndex < len(commitsBehind):
                        text = commitsBehind[behindIndex].getDescription()
                        output += '  ' + padOrTruncate(text, COLUMN_WIDTH)
                        behindIndex += 1

                    print(output)

        return returnVal

class CommandRepo:
    """
    A class used for the repo subcommand
    """

    def __init__(self, scriptName, args):
        """
        Initialize this CommandRepo
        Args
            scriptName: str:         The name used to invoke this script
            args:       list of str: The user-specified command line args, excluding
                                     "repo"
        """

        self.screenWidth = 80
        self._processArgs(scriptName, args)
        self.repository = Repository()

    def _processArgs(self, scriptName, args):
        """
        Process the user-specified command line args
        Args
            args: list of str: The user-specified command line args after "repo"
        """

        i = 0
        while i < len(args):
            if re.match('^--[0-9]+$', args[i]):
                self.screenWidth = int(args[i][2:])

            else:
                print('Unknown commandline argument: ' + args[i])
                sys.exit()

            i += 1

    def run(self):
        """ Print the output for the 'repo' command """

        stashes = FormatterStashes(self.repository.getStashes())
        printed = stashes.show()

        if printed:
            print()

        files = FormatterFiles(
            self.repository.getFilesStaged(),
            self.repository.getFilesModified(),
            self.repository.getFilesUntracked(),
        )
        printed = files.show()

        if printed:
            print()

        branches = FormatterBranches(
            self.screenWidth,
            self.repository.getBranchHierarchy(),
            self.repository.getBranches()
        )
        branches.show()

class Commit:
    """
    A class used to represent a commit
    """

    def __init__(self, hash):
        """
        Initialize this Commit
        Args
            hash: str: The hash for this particular commit
        """

        self.hash = hash

        ## Don't set description unless requested, because some commands
        ## don't need it, and performance takes a hit when lots of commits
        ## being processed
        self.description = None

    def getDescription(self):
        """
        Return the description for this commit
        :returns: str
        """

        if self.description == None:
            self._setDescription()

        return self.description

    def _setDescription(self):
        """
        Set self.description. This is intended to be called only by __init__()
        """
        gitShowOutput = subprocess.check_output(
            [
                'git',
                'show',
                '--no-patch',
                self.hash,
                '--pretty=oneline'
            ],
            universal_newlines = True
        ).splitlines()

        descriptionStart = gitShowOutput[0].find(' ') + 1
        self.description = gitShowOutput[0][descriptionStart:]

class FormatterBranches:
    """
    A class used to format a repository's branches
    """

    def __init__(self, screenWidth, branchHierarchy, branches):
        """
        Initialize this FormatterBranches
        Args
            screenWidth    : int: Required output width
            branchHierarchy: list of Branch objects
            branches:        list of Branch objects: The list of branches
        """

        self.CURRENT_BRANCH_INDICATOR = '* '
        self.EMPTY_CURRENT_BRANCH_INDICATOR = '  '
        self.screenWidth = screenWidth
        self.branchHierarchy = branchHierarchy
        self.branches = branches

    def getFormattedAheadBehind(self, prefix, num):
        """
        Use special criteria to return a string representation of num
        Args
            prefix: str: A string to prefix num with
            num:    int: The number to be prefixed

        :returns: str: See simple logic below
        """

        if num == -1:
            formattedNum = ''
        elif num == 0:
            formattedNum = '.'
        else:
            formattedNum = prefix + str(num)

        return formattedNum

    def show(self):
        """ Print the list of branches in hierarchical order """

        TITLE = '  Remote      Target  '  ## Need space for possibly 3 digit
        REF   = '+100  -100  +100  -100'  ## ahead/behind nums


        ##--------------------------------------------------------------------
        ## Determine the length of the branch name field so we can fit the
        ## remote and merge target information
        ##--------------------------------------------------------------------
        maxMergeTargetLen = 0
        for branch in self.branches:
            mergeTarget = branch.getMergeTargetName()
            targetLength = 0 if mergeTarget == None else len(mergeTarget)
            if targetLength > maxMergeTargetLen:
                maxMergeTargetLen = targetLength

        BRANCH_NAME_LEN = self.screenWidth - maxMergeTargetLen - 1 - len(TITLE) - 1
        BRANCH_NAME_LEN -= len(self.CURRENT_BRANCH_INDICATOR)

        ##--------------------------------------------------------------------
        ## Print the two title lines for remote and merge target ahead/behind
        ## info
        ##--------------------------------------------------------------------
        TITLE_PADDING = self.EMPTY_CURRENT_BRANCH_INDICATOR
        TITLE_PADDING += padOrTruncate(BLANKS, BRANCH_NAME_LEN)
        print(TITLE_PADDING + TITLE)

        ##--------------------------------------------------------------------
        ## Print the summary line for each branch, starting with the "important"
        ## branches (i.e. in hierarchical order)
        ##--------------------------------------------------------------------
        for branch in self.branchHierarchy:
            self._showShortSummary(BRANCH_NAME_LEN, branch)

    def _showShortSummary(self, branchNameLen, branch):
        """
        Show a one-line summary for the specified branch
        Args
            branchNameLen : int:    The length for branch names
            branch:         Branch: The Branch object to be printed
        """

        ##--------------------------------------------------------------------
        ## Determine what the current branch indicator should be:
        ##  - blank if not current branch
        ##  - '*' if it's the current branch
        ##  - flashing if it's important (i.e. dev or master)
        ##--------------------------------------------------------------------
        if branch.isCurrent():
            currentBranchIndicator = formatText(
                TEXT_MAGENTA,
                self.CURRENT_BRANCH_INDICATOR
            )
            if branch.isImportant():
                currentBranchIndicator = formatText(
                    TEXT_FLASHING,
                    currentBranchIndicator
                )
        else:
            currentBranchIndicator = self.EMPTY_CURRENT_BRANCH_INDICATOR

        ##--------------------------------------------------------------------
        ## Get count of commits ahead/behind of remote tracking branch
        ##--------------------------------------------------------------------
        remote = branch.getRemoteTrackingBranchName()
        numAheadRemote = -1
        numBehindRemote = -1

        if remote != None:
            numAheadRemote = len(branch.getCommitsNotIn(remote))
            numBehindRemote = len(branch.getCommitsOnlyIn(remote))

        ##--------------------------------------------------------------------
        ## Get count of commits ahead/behind of merge target
        ##--------------------------------------------------------------------
        mergeTarget = branch.getMergeTargetName()
        numAheadTarget = -1
        numBehindTarget = -1

        if mergeTarget != None:
            numAheadTarget = len(branch.getCommitsNotIn(mergeTarget))
            numBehindTarget = len(branch.getCommitsOnlyIn(mergeTarget))

        ##--------------------------------------------------------------------
        ## Create a string of the branch name and remote ahead/behind info
        ## so we can bold face it if required
        ##--------------------------------------------------------------------
        paddedBranchName = padOrTruncate(branch.getName(), branchNameLen)
        branchAndRemote = paddedBranchName + ' '

        branchAndRemote += rightJustify(
            self.getFormattedAheadBehind('+', numAheadRemote),
            4
        )
        branchAndRemote += '  '
        branchAndRemote += padOrTruncate(
            self.getFormattedAheadBehind('-', numBehindRemote),
            4
        )

        ##--------------------------------------------------------------------
        ## Bold face if the branch is out of sync with its remote
        ##--------------------------------------------------------------------
        if numAheadRemote > 0 or numBehindRemote > 0:
           branchAndRemote = formatText(TEXT_BOLD, branchAndRemote)

        ##--------------------------------------------------------------------
        ## Build up the rest of the output line
        ##--------------------------------------------------------------------
        output = currentBranchIndicator + branchAndRemote
        output += '  '
        output += rightJustify(
            self.getFormattedAheadBehind('+', numAheadTarget),
            4
        )
        output += '  '
        output += padOrTruncate(
            self.getFormattedAheadBehind('-', numBehindTarget),
            4
        )

        if mergeTarget != None:
            output += ' ' + mergeTarget

        print(output)

class FormatterFiles:
    """
    A class used to format a repository's staged, modified, and untracked files
    """

    def __init__(self, stagedFiles, modifiedFiles, untrackedFiles):
        """
        Initialize this FormatterFiles
        Args
            stagedFiles:    list of RepositoryFile objects: The list of staged
                                                            files
            modifiedFiles:  list of RepositoryFile objects: The list of modified
                                                            files
            untrackedFiles: list of RepositoryFile objects: The list of untracked
                                                            files
        :returns: bool: Whether anything was printed
        """

        self.stagedFiles = stagedFiles
        self.modifiedFiles = modifiedFiles
        self.untrackedFiles = untrackedFiles

    def show(self):
        """ Print a staged, modified, and untracked files """

        TITLE_STAGED    = 'Staged   '
        TITLE_MODIFIED  = 'Modified '
        TITLE_UNTRACKED = 'Untracked'
        self.INDENT = BLANKS[0:len(TITLE_UNTRACKED)]

        returnVal = False

        ##--------------------------------------------------------------------
        ## Staged Files
        ##--------------------------------------------------------------------
        lines = []
        for oneFile in self.stagedFiles:
            formattedLine = formatText(
                TEXT_GREEN,
                oneFile.getIndexStatus() + ' ' + oneFile.getName()
            )

            lines.append(formattedLine)

        self.showBlock(TITLE_STAGED, lines)
        if len(lines) != 0:
            returnVal = True

        ##--------------------------------------------------------------------
        ## Modified Files
        ##--------------------------------------------------------------------
        lines = []
        for oneFile in self.modifiedFiles:
            formattedLine = formatText(
                TEXT_RED,
                oneFile.getWorkingTreeStatus() + ' ' + oneFile.getName()
            )

            lines.append(formattedLine)

        if len(lines) != 0:
            if len(self.modifiedFiles) != 0:
                print()

            self.showBlock(TITLE_MODIFIED, lines)
            returnVal = True

        ##--------------------------------------------------------------------
        ## Untracked Files
        ##--------------------------------------------------------------------
        lines = []
        for oneFile in self.untrackedFiles:
            formattedLine = formatText(TEXT_YELLOW, oneFile.getName())

            lines.append(formattedLine)

        if len(lines) != 0:
            if len(self.modifiedFiles) != 0:
                print()

            self.showBlock(TITLE_UNTRACKED, lines)
            returnVal = True

        return returnVal

    def showBlock(self, title, lines):
        """
        Print a block of lines with a title
        Args
            title: str:         The title for this block of lines
            lines: list of str: The list of lines to be printed
        """

        first = True
        for line in lines:
            lead = title if first else self.INDENT
            first = False

            print(lead + ' ' + line)

class FormatterStashes:
    """
    A class used to format a repository's staged, modified, and untracked files
    """

    def __init__(self, stashes):
        """
        Initialize this FormatterStashes
        Args
            stashes: list of Stash objects: The list of stashes to be printed

        :returns: bool: Whether anything was printed
        """

        self.stashes = stashes

    def show(self):
        """ Print a list of stashes """

        TITLE = 'Stashes  '
        INDENT = BLANKS[0:len(TITLE)]

        first = True
        for stash in self.stashes:
            lead = TITLE if first else INDENT
            first = False

            stashName = stash.getName()

            output = lead + ' '
            output += formatText(TEXT_GREEN, stashName)
            output += ' '
            output += padOrTruncate(
                stash.getDescription(),
                77 - len(lead + stashName)
            )

            print(output)

        ## Return whether anything was printed
        return not first

class Repository:
    """
    A class used to represent the git repository contained in the current
    working directory
    """

    def __init__(self):
        """ Initialize git info corresponding to current directory """

        ## "Important" branches that should be flagged in output
        self.IMPORTANT_BRANCHES = ['dev', 'master']

        ## A mapping of branches to their corresponding merge targets
        self.MERGE_TARGETS = {
            'default': 'dev',
            'noTarget': ['master'],
            'targets': {
                'dev': 'master'
            }
        }


        self.branches = []
        self.branchNames = []
        self.currentBranch= None
        self.detachedHeadState = False
        self.filesModified = []
        self.filesStaged = []
        self.filesUntracked = []
        self.stashes = []

        self.ensureGitTrackedFolder()
        self._populateBranchInfo()
        self._populateFilesInfo()
        self._populateStashInfo()

    def ensureGitTrackedFolder(self):
        """ Ensure this is a git-tracked folder """

        try:
            gitOutput = subprocess.check_output(
                ['git', 'status'],
                stderr=subprocess.STDOUT
            )
        except:
            print("This isn't a git tracked folder.")
            exit()

    def getBranch(self, branchName):
        """
        Return the Branch object whose name is branchName
        :returns: Branch The Branch object
        """

        for branch in self.branches:
            if branch.getName() == branchName:
                return branch

        return None

    def getBranches(self):
        """
        Return a List of the (local) branches
        :returns: list of Branch objects
        """

        return self.branches

    def getBranchHierarchy(self):
        """
        Return a list of Branch objects in the following order:
            - Branches with no merge target
            - Branches whose merge targets have been specified
            - Other branches
        :returns: list of Branch objects
        """

        branchList = self.MERGE_TARGETS['noTarget']
        branchList += self.MERGE_TARGETS['targets'].keys()

        for branch in self.branchNames:
            if branch not in branchList:
                branchList.append(branch)

        returnVal = []
        for branchName in branchList:
            branch = self.getBranch(branchName)
            if branch != None:
                returnVal.append(branch)

        return returnVal

    def getCurrentBranch(self):
        """
        Return the current branch
        :returns: Branch
        """

        return self.currentBranch

    def getFilesModified(self):
        """
        Get a list of this repository's modified files
        :returns: list of str
        """

        return self.filesModified

    def getFilesStaged(self):
        """
        Get a list of this repository's staged files
        :returns: list of str
        """

        return self.filesStaged

    def getFilesUntracked(self):
        """
        Get a list of this repository's untracked files
        :returns: list of str
        """

        return self.filesUntracked

    def getMergeTargetName(self, branchName):
        """
        Return the name of the branch that branchName will merge to
        :returns: str
        """

        if branchName in self.MERGE_TARGETS['noTarget']:
            returnVal = None
        elif branchName in self.MERGE_TARGETS['targets']:
            returnVal = self.MERGE_TARGETS['targets'][branchName]
        else:
            returnVal = self.MERGE_TARGETS['default']

        return returnVal

    def getStashes(self):
        """
        Return a list of Stash objects
        :returns: list of STash objects
        """

        return self.stashes

    def isDetachedHeadState(self):
        """
        Return whether the git repository is in "detached head state"
        :returns: bool
        """

        return self.detachedHeadState

    def _populateBranchInfo(self):
        """
        Populate the information about this repository's branches.
        This is intended to be called only by __init__()
        """

        branchesOutput = subprocess.check_output(
            ['git', 'branch', '--list', '-vv'],
            universal_newlines = True
        ).splitlines()

        for branchOutputLine in branchesOutput:
            isCurrentBranch = False
            remoteTrackingBranchName = None

            branchNameStart = 2
            branchNameEnd = branchOutputLine.index(' ', 2)
            branchName = branchOutputLine[branchNameStart : branchNameEnd]

            self.detachedHeadState = (branchName.startswith('(detached'))

            if not self.detachedHeadState:
                if branchOutputLine[0] == '*':
                    isCurrentBranch = True

                ##-------------------------------------------------------------
                ## Create the new branch object
                ##-------------------------------------------------------------
                isImportant = False
                if branchName in self.IMPORTANT_BRANCHES:
                    isImportant = True

                newBranch = Branch(
                    branchName,
                    isImportant,
                    isCurrentBranch,
                    self.getMergeTargetName(branchName)
                )

                ## Assign some stuff that can only be done after branch object
                ## creation
                self.branches.append(newBranch)
                self.branchNames.append(newBranch.getName())
                if isCurrentBranch:
                    self.currentBranch = newBranch

    def _populateFilesInfo(self):
        """
        Populate the information about this repository's files
        (staged, modified, and untracked).
        This is intended to be called only by __init__()
        """

        gitStatusOutput = subprocess.check_output(
            ['git', 'status', '--porcelain'],
            universal_newlines = True
        ).splitlines()

        for line in gitStatusOutput:
            indexStatus = line[0]
            workingTreeStatus = line[1]
            fileName = line[3:]

            newRepositoryFile = RepositoryFile(
                fileName,
                indexStatus,
                workingTreeStatus
            )

            if indexStatus != ' ' and indexStatus != '?':
                self.filesStaged.append(newRepositoryFile)

            if workingTreeStatus != ' ' and workingTreeStatus != '?':
                self.filesModified.append(newRepositoryFile)

            if indexStatus == '?':
                self.filesUntracked.append(newRepositoryFile)

    def _populateStashInfo(self):
        """
        Populate the information about this repository's stashes.
        This is intended to be called only by __init__()
        """

        stashesOutput = subprocess.check_output(
            ['git', 'stash', 'list'],
            universal_newlines = True
        ).splitlines()

        for stashLine in stashesOutput:
            nameEnd = stashLine.find(':')
            newStash = Stash(stashLine[:nameEnd], stashLine[nameEnd+2:])
            self.stashes.append(newStash)

class RepositoryFile:
    """
    A class used to represent a staged, modified, or untracked file in
    the current git repository
    """

    def __init__(self, name, indexStatus, workingTreeStatus):
        """
        Initialize this RepositoryFile
        Args
            name:             str: The name of this file
            indexStatus       str: The one-character index status of this file
            workingTreeStatus str: The one-character working tree status of this file
        """
        self.name = name
        self.indexStatus = indexStatus
        self.workingTreeStatus = workingTreeStatus

    def getIndexStatus(self):
        """
        Get the one-character index status of this file
        :returns: str
        """

        return self.indexStatus

    def getName(self):
        """
        Get the fully qualified name of this file
        :returns: str
        """

        return self.name

    def getWorkingTreeStatus(self):
        """
        Get the one-character working tree status of this file
        :returns: str
        """

        return self.workingTreeStatus

class Stash:
    """
    A class used to represent one stash
    """

    def __init__(self, name, description):
        """ Initialize a stash """

        self.name = name
        self.description = description

    def getDescription(self):
        """
        Return the description of this stash
        :returns: str
        """
        return self.description

    def getName(self):
        """
        Return the name of this stash
        :returns: str
        """

        return self.name

def centerText(text, width):
    padLength = round((width - len(text)) / 2)
    centeredText = BLANKS[:padLength] + text

    return padOrTruncate(centeredText, width)

def formatText(style, text):
    """
    Print the specified text in the specified style
    Args
        style: str: One of the global TEXT_* constants
        text:  str: The text to print
    """

    ESCAPE_MAPPING = {
        TEXT_BOLD: '1',
        TEXT_FLASHING: '5',
        TEXT_GREEN: '32',
        TEXT_MAGENTA: '35',
        TEXT_NORMAL: '0',
        TEXT_RED: '31',
        TEXT_YELLOW: '33'
    }

    escapeStart = '\033[' + ESCAPE_MAPPING[style] + 'm'
    escapeEnd = '\033[' + ESCAPE_MAPPING[TEXT_NORMAL] + 'm'

    return escapeStart + text + escapeEnd

##----------------------------------------------------------------------------
## main()
##      Drive the whole process
##----------------------------------------------------------------------------
def main():
    if len(sys.argv) == 1:
        cmdRepo = CommandRepo(sys.argv[0], [])
        cmdRepo.run()

    else:
        if sys.argv[1] == 'repo':
            cmdRepo = CommandRepo(sys.argv[0], sys.argv[2:])
            cmdRepo.run()

        elif sys.argv[1] == 'branch':
            cmdBranch = CommandBranch(sys.argv[0], sys.argv[2:])
            cmdBranch.run()

        else:
            print('Usage: ' + sys.argv[0] + '[repo | branch] [options]')
            print('    repo   - Show a summary of the current git repository.')
            print('             This is the default if neither \'repo\' nor \'branch\' is specified.')
            print()
            print('             Options:')
            print('                 --n - Format output for a screen width of n characters')
            print()
            print('    branch - Show a summary of the current branch, including remote name,')
            print('             merge target name, commits differing from the remote, and')
            print('             number of commits differing from merge target')
            print()
            print('             Options:')
            print('                 --target - Show the commits differing from the merge target')
            print('                            instead of just the number')
            print('                 --n      - Format output for a screen width of n characters')

##----------------------------------------------------------------------------
## padOrTruncate(text, length)
##      - Pad or truncate the specified string to return one of the exact
##        specified length
##----------------------------------------------------------------------------
def padOrTruncate(text, length):
    returnVal = text

    if len(text) < length:
        formatString = '{{:<{}}}'.format(str(length))
        returnVal = formatString.format(text)

    elif len(text) > length:
        returnVal = text[0:length]

    return returnVal


def rightJustify(text, width):
    padLength = width - len(text)
    justifiedText = BLANKS[:padLength] + text

    return justifiedText

##----------------------------------------------------------------------------
##----------------------------------------------------------------------------
main()
